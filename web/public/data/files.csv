id,path,content,ast,amountOfKgrams,extra
93,../exam-folder/Peter Dawyndt/geometrische-letters.py,"""""""
>>> font = read_font('font.txt')
>>> font['E']
(4, 0)
>>> font['R']
(2, 1)
>>> font['G']
(1, 1)
>>> font['O']
(0, 1)

>>> line_count('ERGONOMICS', font)
(17, 6)
>>> count_straight_lines('ERGONOMICS', font)
17
>>> count_curved_lines('ERGONOMICS', font)
6

>>> straight_lines_only('dictionary.txt', font) == {'ALKALINE', 'MILLENNIAL', 'INFINITELY'}
True
>>> curved_lines_only('dictionary.txt', font) == {'COCCUS', 'COUSCOUS'}
True
>>> balanced_lines('dictionary.txt', font) == {'AUGUSTUS', 'PROCESSORS', 'CROSSROAD', 'COLUMBUS', 'CROSSWORDS'}
True
""""""

def read_font(filename):

    font = {}
    with open(filename, 'r', encoding='utf-8') as characters:
        for line in characters:
            character, straight_lines, curved_lines = line.split()
            font[character] = (int(straight_lines), int(curved_lines))

    return font

def line_count(text, font):

    straight_lines, curved_lines = 0, 0
    for character in text:
        curved, straight = font.get(character, (0, 0))
        straight_lines += curved
        curved_lines += straight

    return straight_lines, curved_lines

def count_straight_lines(text, font):

    return line_count(text, font)[0]

def count_curved_lines(text, font):

    return line_count(text, font)[1]

def straight_lines_only(filename, font):

    with open(filename, 'r', encoding='utf8') as words:
        return {
            word.rstrip('\n') for word in words
            if count_curved_lines(word, font) == 0
        }

def curved_lines_only(filename, font):

    with open(filename, 'r', encoding='utf8') as words:
        return {
            word.rstrip('\n') for word in words
            if count_straight_lines(word, font) == 0
        }

def balanced_lines(filename, font):

    def ispassend(word):
        curved, straight = line_count(word, font)
        return curved == straight

    with open(filename, 'r', encoding='utf8') as words:
        return {word.rstrip('\n') for word in words if ispassend(word)}

if __name__ == '__main__':
    import doctest
    doctest.testmod()
",( module ( expression_statement ( string ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ( keyword_argument ( identifier ) ( string ) ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( tuple ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( expression_list ( integer ) ( integer ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ( tuple ( integer ) ( integer ) ) ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ( return_statement ( expression_list ( identifier ) ( identifier ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ( keyword_argument ( identifier ) ( string ) ) ) ) ( identifier ) ) ) ( block ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ( keyword_argument ( identifier ) ( string ) ) ) ) ( identifier ) ) ) ( block ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( return_statement ( comparison_operator ( identifier ) ( identifier ) ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ( keyword_argument ( identifier ) ( string ) ) ) ) ( identifier ) ) ) ( block ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),82,"{""filename"":""Peter Dawyndt/geometrische-letters.py"",""fullName"":""Peter Dawyndt"",""id"":""3"",""status"":""correct"",""submissionID"":""6735449"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-13T12:46:09.000Z"",""labels"":""admin""}"
94,../exam-folder/Toon Baeyens/geometrische-letters.py,"# 19

def lees_lettertype(lettertype):
    d = {}
    with open(lettertype) as f:
        for line in f:
            l, r, k = line.strip().split("" "")
            d[l] = (int(r), int(k))
    return d


def aantal_rechte_lijnen(woord, lettertype):
    return sum(lettertype[letter][0] for letter in woord if letter in lettertype)

def aantal_kromme_lijnen(woord, lettertype):
    return sum(lettertype[letter][1] for letter in woord if letter in lettertype)

def enkel_lijnen(f):
    def r(woordenboek, lettertype):
        with open(woordenboek) as w:
            return {woord.strip() for woord in w if f(woord.strip(), lettertype)}

    return r

enkel_rechte_lijnen = enkel_lijnen(lambda w, l: aantal_kromme_lijnen(w, l) == 0)
enkel_kromme_lijnen = enkel_lijnen(lambda w, l: aantal_rechte_lijnen(w, l) == 0)
gebalanceerde_lijnen = enkel_lijnen(lambda w, l: aantal_rechte_lijnen(w, l) == aantal_kromme_lijnen(w, l))",( module ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( tuple ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( call ( identifier ) ( generator_expression ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( comparison_operator ( identifier ) ( identifier ) ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( call ( identifier ) ( generator_expression ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( comparison_operator ( identifier ) ( identifier ) ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( block ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( lambda ( lambda_parameters ( identifier ) ( identifier ) ) ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( lambda ( lambda_parameters ( identifier ) ( identifier ) ) ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( lambda ( lambda_parameters ( identifier ) ( identifier ) ) ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ) ) ) ) ),59,"{""filename"":""Toon Baeyens/geometrische-letters.py"",""fullName"":""Toon Baeyens"",""id"":""891"",""status"":""correct"",""submissionID"":""6744074"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T09:30:00.000Z"",""labels"":""admin""}"
95,../exam-folder/Charlotte Van Petegem/geometrische-letters.py,"""""""
>>> lettertype = lees_lettertype('lettertype.txt')
>>> lettertype['E']
(4, 0)
>>> lettertype['R']
(2, 1)
>>> lettertype['G']
(1, 1)
>>> lettertype['O']
(0, 1)

>>> aantal_lijnen('ERGONOMIE', lettertype)
(21, 4)
>>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
21
>>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
4

>>> enkel_rechte_lijnen('woordenboek.txt', lettertype) == {'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
True
>>> enkel_kromme_lijnen('woordenboek.txt', lettertype) == {'COCCUS', 'COUSCOUS'}
True
>>> gebalanceerde_lijnen('woordenboek.txt', lettertype) == {'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}
True
""""""

def lees_lettertype(bestandsnaam):

    lettertype = {}
    with open(bestandsnaam, 'r', encoding='utf-8') as karakters:
        for regel in karakters:
            karakter, rechte_lijnen, kromme_lijnen = regel.split()
            lettertype[karakter] = (int(rechte_lijnen), int(kromme_lijnen))

    return lettertype

def aantal_lijnen(tekst, lettertype):

    rechte_lijnen, kromme_lijnen = 0, 0
    for karakter in tekst:
        recht, krom = lettertype.get(karakter, (0, 0))
        rechte_lijnen += recht
        kromme_lijnen += krom

    return rechte_lijnen, kromme_lijnen

def aantal_rechte_lijnen(tekst, lettertype):

    return aantal_lijnen(tekst, lettertype)[0]

def aantal_kromme_lijnen(tekst, lettertype):

    return aantal_lijnen(tekst, lettertype)[1]

def enkel_rechte_lijnen(bestandsnaam, lettertype):

    with open(bestandsnaam, 'r', encoding='utf8') as woorden:
        return {
            woord.rstrip('\n') for woord in woorden
            if aantal_kromme_lijnen(woord, lettertype) == 0
        }

def enkel_kromme_lijnen(bestandsnaam, lettertype):

    with open(bestandsnaam, 'r', encoding='utf8') as woorden:
        return {
            woord.rstrip('\n') for woord in woorden
            if aantal_rechte_lijnen(woord, lettertype) == 0
        }

def gebalanceerde_lijnen(bestandsnaam, lettertype):

    def ispassend(woord):
        recht, krom = aantal_lijnen(woord, lettertype)
        return recht == krom

    with open(bestandsnaam, 'r', encoding='utf8') as woorden:
        return {woord.rstrip('\n') for woord in woorden if ispassend(woord)}

if __name__ == '__main__':
    import doctest
    doctest.testmod()
",( module ( expression_statement ( string ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ( keyword_argument ( identifier ) ( string ) ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( tuple ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( expression_list ( integer ) ( integer ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ( tuple ( integer ) ( integer ) ) ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ( return_statement ( expression_list ( identifier ) ( identifier ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ( keyword_argument ( identifier ) ( string ) ) ) ) ( identifier ) ) ) ( block ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ( keyword_argument ( identifier ) ( string ) ) ) ) ( identifier ) ) ) ( block ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( return_statement ( comparison_operator ( identifier ) ( identifier ) ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ( keyword_argument ( identifier ) ( string ) ) ) ) ( identifier ) ) ) ( block ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),82,"{""filename"":""Charlotte Van Petegem/geometrische-letters.py"",""fullName"":""Charlotte Van Petegem"",""id"":""1298"",""status"":""correct"",""submissionID"":""6743638"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T08:39:53.000Z"",""labels"":""admin""}"
96,../exam-folder/Stan Willemyns/geometrische-letters.py,"def lees_lettertype(file_beschrijving_str):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> lettertype['E']
    (4, 0)
    >>> lettertype['R']
    (2, 1)
    >>> lettertype['G']
    (1, 1)
    >>> lettertype['O']
    (0, 1)
    """"""
    file_beschrijving = open(file_beschrijving_str, 'r')
    lines_list = file_beschrijving.readlines()
    return {line.split(' ')[0]: (int(line.split(' ')[1]), int(line.strip().split(' ')[2])) for line in lines_list}


def aantal_rechte_lijnen(w_str, beschrijving_dict):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')

    >>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
    21
    """"""
    aantal_int = 0
    for letter in w_str:
        aantal_int += beschrijving_dict.get(letter, (0, 0))[0]
    return aantal_int


def aantal_kromme_lijnen(w_str, beschrijving_dict):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
    4
    """"""
    aantal_int = 0
    for letter in w_str:
        aantal_int += beschrijving_dict.get(letter, (0, 0))[1]
    return aantal_int


def enkel_rechte_lijnen(file_reekswoorden_str, beschrijving_dict):
    woorden_set = set()
    file_reekswoorden = open(file_reekswoorden_str, 'r')
    woorden_list = [i.strip() for i in file_reekswoorden.readlines()]
    for woord in woorden_list:
        if aantal_kromme_lijnen(woord, beschrijving_dict) == 0:
            woorden_set.add(woord)
    return woorden_set


def enkel_kromme_lijnen(file_reekswoorden_str, beschrijving_dict):
    woorden_set = set()
    file_reekswoorden = open(file_reekswoorden_str, 'r')
    woorden_list = [i.strip() for i in file_reekswoorden.readlines()]
    for woord in woorden_list:
        if aantal_rechte_lijnen(woord, beschrijving_dict) == 0:
            woorden_set.add(woord)
    return woorden_set


def gebalanceerde_lijnen(file_reekswoorden_str, beschrijving_dict):
    woorden_set = set()
    file_reekswoorden = open(file_reekswoorden_str, 'r')
    woorden_list = [i.strip() for i in file_reekswoorden.readlines()]
    for woord in woorden_list:
        if aantal_rechte_lijnen(woord, beschrijving_dict) == aantal_kromme_lijnen(woord, beschrijving_dict):
            woorden_set.add(woord)
    return woorden_set


if __name__ == '__main__':
    import doctest
    doctest.testmod()
    ",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( return_statement ( dictionary_comprehension ( pair ( subscript ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ( integer ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ( string ) ) ) ( integer ) ) ) ) ) ) ( for_in_clause ( identifier ) ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ( tuple ( integer ) ( integer ) ) ) ) ( integer ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ( tuple ( integer ) ( integer ) ) ) ) ( integer ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( list_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( for_in_clause ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( list_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( for_in_clause ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( list_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( for_in_clause ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),99,"{""filename"":""Stan Willemyns/geometrische-letters.py"",""fullName"":""Stan Willemyns"",""id"":""11499"",""status"":""correct"",""submissionID"":""6749679"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:46:30.000Z"",""labels"":""keuz""}"
97,../exam-folder/Maud Boghaert/geometrische-letters.py,"def lees_lettertype(bestand):
#dictionary aanmaken die elk eerste karakter afbeeldt op het tweede en laatste karakter
    dict={}
    lijst=[]
    invoer=open(bestand,'r')
    for regel in invoer:
        regel=regel.rstrip('\n')
        regel.split(' ')
        lijst.append(int(regel[2]))
        lijst.append(int(regel[-1]))
        dict[regel[0]]=tuple(lijst)
        lijst=[]
    return dict

def aantal_rechte_lijnen(woord,lettertype):
#aantalrechtelijnen= telkens het eerste karakter dat de waarde is vd sleutel horende bij het karakter, per karakter aantal erbij tellen
    aantal=0
    for karakter in woord:
        if karakter.isalpha():
         aantal+=lettertype[karakter][0]
    return aantal
        
def aantal_kromme_lijnen(woord,lettertype):
#zelfde als vorige functie maar dan het tweede karakter van de tuple erbij tellen
    aantal=0
    for karakter in woord:
        if karakter.isalpha():
            aantal+=lettertype[karakter][1]
    return aantal
    
def enkel_rechte_lijnen(bestand,dict):
#vorigefunctie toepassen en zo te weten komen waar 0 kromme lijnen zijn, hier een verz van maken
    verz=set()
    invoer=open(bestand,'r')
    for regel in invoer:
        regel=regel.rstrip('\n')
        if aantal_kromme_lijnen(regel,dict)==0:
            verz.add(regel)
    return verz
def enkel_kromme_lijnen(bestand,dict):
#zelfde als vorige functie, maar nu de woorden zoeken waar 0 rechte lijnen in zijn door een vorige functie op te roepen
    verz=set()
    invoer=open(bestand,'r')
    for regel in invoer:
        regel =regel.rstrip('\n')
        if aantal_rechte_lijnen(regel,dict)==0:
            verz.add(regel)
    return verz
    
def gebalanceerde_lijnen(bestand,dict):
# voor elk woord zowel het aantal kromme lijnen als het aantal rechte lijnen tellen, als beide gelijk zijn in aantal het woord toevoegen aan de verzameling
    verz=set()
    invoer=open(bestand,'r')
    for regel in invoer:
        regel=regel.rstrip('\n')
        k = aantal_kromme_lijnen(regel,dict)
        r = aantal_rechte_lijnen(regel,dict)
        if k==r:
            verz.add(regel)
    return verz
        ",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( expression_statement ( assignment ( identifier ) ( list ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( unary_operator ( integer ) ) ) ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( list ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),107,"{""filename"":""Maud Boghaert/geometrische-letters.py"",""fullName"":""Maud Boghaert"",""id"":""11508"",""status"":""correct"",""submissionID"":""6748512"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:19:09.000Z"",""labels"":""geog""}"
98,../exam-folder/Bryan Larez Larez/geometrische-letters.py,"'''
>>> lettertype = lees_lettertype('lettertype.txt')
>>> lettertype['E']
(4, 0)
>>> lettertype['R']
(2, 1)
>>> lettertype['G']
(1, 1)
>>> lettertype['O']
(0, 1)

>>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
21
>>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
4

>>> enkel_rechte_lijnen('woordenboek.txt', lettertype)
{'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
>>> enkel_kromme_lijnen('woordenboek.txt', lettertype)
{'COCCUS', 'COUSCOUS'}
>>> gebalanceerde_lijnen('woordenboek.txt', lettertype)
{'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}
'''

def lees_lettertype(bestand):

    dictt = {}  #dictionary dat teruggegeven moet worden
    with open(bestand) as bestand_o:
        for regel in bestand_o:
            lijst = regel.rstrip('\n').split(' ') #Geen 'enter' en een lijst maken.
            dictt[lijst[0]] = (int(lijst[1]), int(lijst[2])) #Hier zorg ik ervoor dat er een key met
            # hun corresponderen values wordt gemaakt en toegevoegd

    return dictt

def aantal_rechte_lijnen(woord, lettertype):

    tot_aantal_rechte_lijnen = 0
    for letter in woord: #kijken naar elke letter in het gegeven woord
        try:
            tot_aantal_rechte_lijnen += lettertype[letter][0] #de aantal rechten in dat letter toevoegen
        # aan het totale aantal rechte lijnen
        except KeyError:
            pass
    return tot_aantal_rechte_lijnen

def aantal_kromme_lijnen(woord, lettertype):

    tot_aantal_kromme_lijnen = 0
    for letter in woord:  # kijken naar elke letter in het gegeven woord
        try:
            tot_aantal_kromme_lijnen += lettertype[letter][1]  # de aantal rechten in dat letter toevoegen
        # aan het totale aantal kromme lijnen
        except KeyError:
            pass
    return tot_aantal_kromme_lijnen

def enkel_rechte_lijnen(woordenboek, lettertype):

    verzameling_van_woorden = set()
    with open(woordenboek) as woordenboek_o:
        for woord in woordenboek_o: #Hier zorg ik ervoor dat het woord in het woordenboek alleen
            # toegevoegd wordt als het alleen geschreven kan worden met rechte lijnen.
            woord1 = woord.rstrip('\n')
            if aantal_rechte_lijnen(woord1, lettertype) and not aantal_kromme_lijnen(woord1, lettertype):
                verzameling_van_woorden.add(woord1)

    return verzameling_van_woorden

def enkel_kromme_lijnen(woordenboek, lettertype):

    verzameling_van_woorden = set()
    with open(woordenboek) as woordenboek_o:
        for woord in woordenboek_o:  # Hier zorg ik ervoor dat het woord in het woordenboek alleen
            # toegevoegd wordt als het alleen geschreven kan worden met kromme lijnen.
            woord1 = woord.rstrip('\n')
            if not aantal_rechte_lijnen(woord1, lettertype) and aantal_kromme_lijnen(woord1, lettertype):
                verzameling_van_woorden.add(woord1)

    return verzameling_van_woorden

def gebalanceerde_lijnen(woordenboek, lettertype):
    verzameling_van_woorden = set()
    with open(woordenboek) as woordenboek_o:
        for woord in woordenboek_o:
            woord1 = woord.rstrip('\n')
            if aantal_rechte_lijnen(woord1, lettertype) == aantal_kromme_lijnen(woord1, lettertype):
                verzameling_van_woorden.add(woord1)

    return verzameling_van_woorden


if __name__ == '__main__':
    import doctest
    doctest.testmod()
",( module ( expression_statement ( string ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( comment ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ) ) ( comment ) ( comment ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( try_statement ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( comment ) ) ( comment ) ( except_clause ( identifier ) ( block ( pass_statement ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( try_statement ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( comment ) ) ( comment ) ( except_clause ( identifier ) ( block ( pass_statement ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( comment ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( boolean_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( not_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( comment ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( not_operator ( boolean_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),102,"{""filename"":""Bryan Larez Larez/geometrische-letters.py"",""fullName"":""Bryan Larez Larez"",""id"":""11513"",""status"":""correct"",""submissionID"":""6747949"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:03:44.000Z"",""labels"":""fyss""}"
99,../exam-folder/Jarne Voorspools/geometrische-letters.py,"def lees_lettertype(bestand):

    gelezen = open(bestand, ""r"")
    letters = []
    rechte = []
    kromme = []

    # alle waarden in een afzonderlijke lijst steken om gemakkelijker met de dictionary te werken
    for regel in gelezen:
        lijn = regel.split("" "")
        letters.append(lijn[0])
        rechte.append(int(lijn[1]))
        kromme.append(int(lijn[2].rstrip(""\n"")))

    # elke letter aan de dictionary toevoegen met de bijpassende waarden
    dictionary = {}
    for i in range(len(letters)):
        dictionary[letters[i]] = (rechte[i], kromme[i])

    return dictionary

def aantal_rechte_lijnen(woord, lettertype):

    totaal = 0

    # elke letter van het woord aflopen en de rechte lijnen optellen
    for i in woord:
        if i in lettertype:
            totaal += lettertype[i][0]
    return totaal

def aantal_kromme_lijnen(woord, lettertype):

    totaal = 0
    # elke letter overlopen en het aantal kromme lijnen optellen
    for i in woord:
        if i in lettertype:
            totaal += lettertype[i][1]
    return totaal

def enkel_rechte_lijnen(bestand, lettertype):

    totaal = set()
    woorden = open(bestand, ""r"")

    # elk woord uit het bestand afgaan en als het aantal kromme lijnen in het woord 0 is,
    # voeg het woord dan toe aan de lijst
    for woord in woorden:
        woord = woord.rstrip(""\n"")
        if aantal_kromme_lijnen(woord, lettertype) == 0:
            totaal.add(woord)
    return totaal

def enkel_kromme_lijnen(bestand, lettertype):

    totaal = set()
    woorden = open(bestand, ""r"")

    # elk woord overlopen en als het aantal rechte lijnen 0 is, voeg het woord dan toe aan de lijst
    for woord in woorden:
        woord = woord.rstrip(""\n"")
        if aantal_rechte_lijnen(woord, lettertype) == 0:
            totaal.add(woord)
    return totaal

def gebalanceerde_lijnen(bestand, lettertype):
    
    totaal = set()
    woorden = open(bestand, ""r"")
    
    # elk woord overlopen en als het aantal rechte lijnen gelijk is aan het aantal kromme,
    # voeg dan het woord toe aan de lijst
    for woord in woorden:
        woord = woord.rstrip(""\n"")
        if aantal_kromme_lijnen(woord, lettertype) == aantal_rechte_lijnen(woord, lettertype):
            totaal.add(woord)
    return totaal",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( list ) ) ) ( expression_statement ( assignment ( identifier ) ( list ) ) ) ( expression_statement ( assignment ( identifier ) ( list ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( identifier ) ( argument_list ( call ( attribute ( subscript ( identifier ) ( integer ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( block ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( identifier ) ) ) ( tuple ( subscript ( identifier ) ( identifier ) ) ( subscript ( identifier ) ( identifier ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( comment ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( comment ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),127,"{""filename"":""Jarne Voorspools/geometrische-letters.py"",""fullName"":""Jarne Voorspools"",""id"":""11514"",""status"":""correct"",""submissionID"":""6749848"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:51:28.000Z"",""labels"":""fyss""}"
100,../exam-folder/Maud Vervaet/geometrische-letters.py,"def lees_lettertype(locatie):
    dictionary = {}
    for regel in open(locatie, 'r'):
        regel = regel.strip('\n')
        regel = regel.split(' ')
        letter, rechte, kromme = regel[0], regel[1], regel[2]
        # dictionary maken die letter afbeeldt op tuple met aantal rechte en aantal kromme lijnen
        dictionary[letter] = int(rechte), int(kromme)
    return dictionary


def aantal_rechte_lijnen(woord, beschrijving_dict):
    rechtes = 0
    for letter in woord:
        if letter in beschrijving_dict.keys():
            # aantal rechte lijnen uit dicitonary voor elke letter halen en optellen bij totaal aantal rechte lijnen
            rechte, _ = beschrijving_dict[letter]
            rechtes += rechte
    return rechtes


def aantal_kromme_lijnen(woord, beschrijving_dict):
    krommen = 0
    for letter in woord:
        if letter in beschrijving_dict.keys():
            # aantal kromme lijnen uit dicitonary voor elke letter halen en optellen bij totaal aantal kromme lijnen
            _, kromme = beschrijving_dict[letter]
            krommen += kromme
    return krommen


def enkel_rechte_lijnen(locatie_reeks, beschrijving_dict):
    woorden = set()
    for woord in open(locatie_reeks, 'r'):
        woord = woord.strip('\n')
        # als aantal kromme lijnen = 0, bestaat het teken enkel uit rechte lijnen en moet het woord toegevoegd worden
        krommen = aantal_kromme_lijnen(woord, beschrijving_dict)
        if krommen == 0:
            woorden.add(woord)
    return woorden


def enkel_kromme_lijnen(locatie_reeks, beschrijving_dict):
    woorden = set()
    for woord in open(locatie_reeks, 'r'):
        woord = woord.strip('\n')
        # als aantal rechte lijnen = 0, bestaat het teken enkel uit kromme lijnen en moet het woord toegevoegd worden
        rechten = aantal_rechte_lijnen(woord, beschrijving_dict)
        if rechten == 0:
            woorden.add(woord)
    return woorden


def gebalanceerde_lijnen(locatie_reeks, beschrijving_dict):
    woorden = set()
    for woord in open(locatie_reeks, 'r'):
        woord = woord.strip('\n')
        # als het aantal rechte lijnen gelijk is aan het aantal kromme lijnen, moet het woord toegevoegd worden
        rechten = aantal_rechte_lijnen(woord, beschrijving_dict)
        krommen = aantal_kromme_lijnen(woord, beschrijving_dict)
        if rechten == krommen:
            woorden.add(woord)
    return woorden
",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( expression_list ( subscript ( identifier ) ( integer ) ) ( subscript ( identifier ) ( integer ) ) ( subscript ( identifier ) ( integer ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( expression_list ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( comment ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( subscript ( identifier ) ( identifier ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( comment ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( subscript ( identifier ) ( identifier ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),96,"{""filename"":""Maud Vervaet/geometrische-letters.py"",""fullName"":""Maud Vervaet"",""id"":""11515"",""status"":""correct"",""submissionID"":""6749621"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:45:12.000Z"",""labels"":""geog""}"
101,../exam-folder/Tanisha Moons/geometrische-letters.py,"def read_font(text):
    r = -1
    k = -1
    dictionary = {}
    for line in open(text, 'r'):
        line = line.replace(' ', '')
        line = line.strip()
        for pos in range(len(line)):
            if pos == 0:
                key = line[pos]
            elif pos == 1:
                r = int(line[pos])
            elif pos == 2:
                k = int(line[pos])
        dictionary[key] = (r, k)
    return dictionary

def count_straight_lines(word, dictionary):
    total = 0
    for letter in word:
        if letter in dictionary:
            pos = dictionary[letter]
            num_lines = pos[0]
            total += int(num_lines)
    return total
def count_curved_lines(word, dictionary):
    total = 0
    for letter in word:
        if letter in dictionary:
            pos = dictionary[letter]
            num_lines = pos[1]
            total += int(num_lines)
    return total

def straight_lines_only(text, dictionary):
    result = set()
    for word in open(text):
        word = word.replace('\n', '').replace('\r', '')
        curved = count_curved_lines(word, dictionary)
        if curved == 0:
            result.add(word)
    return result

def curved_lines_only(text, dictionary):
    result = set()
    for word in open(text):
        word = word.replace('\n', '').replace('\r', '')
        straight = count_straight_lines(word, dictionary)
        if straight == 0:
            result.add(word)
    return result

def balanced_lines(text, dictionary):
    result = set()
    for word in open(text):
        word = word.replace('\n', '').replace('\r', '')
        straight = count_straight_lines(word, dictionary)
        curved = count_curved_lines(word, dictionary)
        if straight == curved:
            result.add(word)
    return result",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( unary_operator ( integer ) ) ) ) ( expression_statement ( assignment ( identifier ) ( unary_operator ( integer ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( block ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( identifier ) ) ) ) ) ( elif_clause ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( identifier ) ) ) ) ) ) ) ) ( elif_clause ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( identifier ) ) ) ) ) ) ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( tuple ( identifier ) ( identifier ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( identifier ) ) ) ) ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( identifier ) ) ) ) ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ( string ) ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ( string ) ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ( string ) ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),110,"{""filename"":""Tanisha Moons/geometrische-letters.py"",""fullName"":""Tanisha Moons"",""id"":""7959"",""status"":""correct"",""submissionID"":""6747169"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T13:39:57.000Z"",""labels"":""biol""}"
102,../exam-folder/Febe Engelbeen/geometrische-letters.py,"def lees_lettertype(tekst):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> lettertype['E']
    (4, 0)
    >>> lettertype['R']
    (2, 1)
    >>> lettertype['G']
    (1, 1)
    >>> lettertype['O']
    (0, 1)
    """"""

    waarden = dict()
    for rij in open(tekst, 'r'):
        karakter, recht, krom = rij.strip('\n').split(' ')
        waarden[karakter] = (int(recht), int(krom))
    return waarden


def aantal_rechte_lijnen(woord, waarden):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
    21
    """"""

    som = 0
    for letter in woord:
        if letter in waarden.keys():
            som += waarden[letter][0]
    return som


def aantal_kromme_lijnen(woord, waarden):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
    4
    """"""

    som = 0
    for letter in woord:
        if letter in waarden.keys():
            som += waarden[letter][1]
    return som


def enkel_rechte_lijnen(woorden, waarden):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> enkel_rechte_lijnen('woordenboek.txt', lettertype)
    {'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
    """"""

    recht = list()
    for woord in open(woorden, 'r'):
        woord = woord.strip('\n')
        krom = aantal_kromme_lijnen(woord, waarden)
        if krom == 0:
            recht.append(woord)
    return set(recht)

def enkel_kromme_lijnen(woorden, waarden):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> enkel_kromme_lijnen('woordenboek.txt', lettertype)
    {'COCCUS', 'COUSCOUS'}
    """"""

    krom = list()
    for woord in open(woorden, 'r'):
        woord = woord.strip('\n')
        recht = aantal_rechte_lijnen(woord, waarden)
        if recht == 0:
            krom.append(woord)
    return set(krom)


def gebalanceerde_lijnen(woorden, waarden):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> gebalanceerde_lijnen('woordenboek.txt', lettertype)
    {'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}
    """"""

    evenveel = list()
    for woord in open(woorden, 'r'):
        woord = woord.strip('\n')
        krom = aantal_kromme_lijnen(woord, waarden)
        recht = aantal_rechte_lijnen(woord, waarden)
        if krom == recht:
            evenveel.append(woord)
    return set(evenveel)",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( tuple ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ),87,"{""filename"":""Febe Engelbeen/geometrische-letters.py"",""fullName"":""Febe Engelbeen"",""id"":""7998"",""status"":""correct"",""submissionID"":""6749103"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:32:55.000Z"",""labels"":""bcbt""}"
103,../exam-folder/Ella Meynckens/geometrische-letters.py,"def lees_lettertype(letters):
    with open(letters) as f:
        lijst = f.read().splitlines()
    dic = {}
    for i in lijst:
        i = i.split()
        dic[i[0]] = (int(i[1]), int(i[2]))
    return dic
def aantal_rechte_lijnen(woord, lettertype):
    som = 0
    for i in woord:
        if i in lettertype:
            som += lettertype[i][0]
    return som
def aantal_kromme_lijnen(woord, lettertype):
    som = 0
    for i in woord:
        if i in lettertype:
            som += lettertype[i][1]
    return som
def enkel_rechte_lijnen(woorden, lettertype):
    with open(woorden) as f:
        lijst = f.read().splitlines()
    s = set()
    krom = True
    for i in lijst:
        for j in i:
            if j in lettertype:
                if lettertype[j][1] != 0:
                    krom = False
        if krom == True:
            s.add(i)
        krom = True
    return s
def enkel_kromme_lijnen(woorden, lettertype):
    with open(woorden) as f:
        lijst = f.read().splitlines()
    s = set()
    krom = True
    for i in lijst:
        for j in i:
            if j in lettertype:
                if lettertype[j][0] != 0:
                    krom = False
        if krom == True:
            s.add(i)
        krom = True
    return s
def gebalanceerde_lijnen(woorden, lettertype):
    with open(woorden) as f:
        lijst = f.read().splitlines()
    s = set()
    somR = 0
    somK = 0
    for woord in lijst:
        for i in woord:
            if i in lettertype:
                somR += lettertype[i][0]
                somK += lettertype[i][1]
        if somK == somR:
            s.add(woord)
        somR = 0
        somK = 0
    return s",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( true ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( if_statement ( comparison_operator ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ( integer ) ) ( block ( expression_statement ( assignment ( identifier ) ( false ) ) ) ) ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( true ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( true ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( true ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( if_statement ( comparison_operator ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ( integer ) ) ( block ( expression_statement ( assignment ( identifier ) ( false ) ) ) ) ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( true ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( true ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),123,"{""filename"":""Ella Meynckens/geometrische-letters.py"",""fullName"":""Ella Meynckens"",""id"":""8306"",""status"":""correct"",""submissionID"":""6749699"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:46:57.000Z"",""labels"":""bcbt""}"
104,../exam-folder/Stan Aelterman/geometrische-letters.py,"def lees_lettertype(locatie):
    bestand = open(locatie, 'r')
    uitkomst = {}
    for regel in bestand:
        uitkomst[regel[0]] = int(regel[2]), int(regel[4])
    bestand.close()
    return uitkomst


def aantal_rechte_lijnen(woord, beschrijving):
    hoeveelheid = 0
    for letter in woord:
        try:
            hoeveelheid += beschrijving[letter][0]
        except KeyError:
            hoeveelheid == hoeveelheid # Doe gewoon niets
    return hoeveelheid


def aantal_kromme_lijnen(woord, beschrijving):
    hoeveelheid = 0
    for letter in woord:
        try:
            hoeveelheid += beschrijving[letter][1]
        except KeyError:
            hoeveelheid == hoeveelheid # Doe gewoon niets
    return hoeveelheid


def enkel_rechte_lijnen(locatie, beschrijving):
    verzameling = set()
    bestand = open(locatie, 'r')
    for woord in bestand:
        if aantal_kromme_lijnen(woord, beschrijving) == 0:
            verzameling.add(woord[:-1])
    bestand.close()

    return verzameling


def enkel_kromme_lijnen(locatie, beschrijving):
    verzameling = set()
    bestand = open(locatie, 'r')
    for woord in bestand:
        if aantal_rechte_lijnen(woord, beschrijving) == 0:
            verzameling.add(woord[:-1])
    bestand.close()

    return verzameling


def gebalanceerde_lijnen(locatie, beschrijving):
    verzameling = set()
    bestand = open(locatie, 'r')
    for woord in bestand:
        if aantal_kromme_lijnen(woord, beschrijving) == aantal_rechte_lijnen(woord, beschrijving):
            verzameling.add(woord[:-1])
    bestand.close()

    return verzameling
",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( expression_list ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( try_statement ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ( except_clause ( identifier ) ( block ( expression_statement ( comparison_operator ( identifier ) ( identifier ) ) ) ( comment ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( try_statement ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ( except_clause ( identifier ) ( block ( expression_statement ( comparison_operator ( identifier ) ( identifier ) ) ) ( comment ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( identifier ) ) ) ) ),99,"{""filename"":""Stan Aelterman/geometrische-letters.py"",""fullName"":""Stan Aelterman"",""id"":""11527"",""status"":""correct"",""submissionID"":""6748798"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:25:28.000Z"",""labels"":""fyss""}"
105,../exam-folder/Laura De Fraine/geometrische-letters.py,"def lees_lettertype(tekst):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> lettertype['E']
    (4, 0)
    >>> lettertype['R']
    (2, 1)
    >>> lettertype['G']
    (1, 1)
    >>> lettertype['O']
    (0, 1)
    """"""
    oplossing = {}
    invoer = open(tekst, 'r')
    for regel in invoer:
        tekst = ''
        regel = regel.rstrip()
        for element in regel:
            if element.isalpha() or element.isdigit():
                tekst += element
        type = (int(tekst[1]), int(tekst[-1]))
        letter = tekst[0]
        oplossing[letter] = type
    return oplossing
def aantal_rechte_lijnen(woord, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')

    >>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
    21
    """"""
    totaal = 0
    for element in woord:
        if element in lettertype:
            waarden = lettertype.get(element)
            totaal += waarden[0]
    return totaal
def aantal_kromme_lijnen(woord, lettertype):
    """"""
     >>> lettertype = lees_lettertype('lettertype.txt')
    >>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
    4
    """"""
    totaal = 0
    for element in woord:
        if element in lettertype:
            waarden = lettertype.get(element)
            totaal += waarden[1]
    return totaal
def enkel_rechte_lijnen(woordenboek, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> enkel_rechte_lijnen('woordenboek.txt', lettertype)
    {'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
    """"""
    woorden = []
    boek = open(woordenboek, 'r')
    for regel in boek:
        regel = regel.rstrip()
        totaal = aantal_kromme_lijnen(regel, lettertype)
        if totaal == 0:
            woorden.append(regel)
    return set(woorden)
def enkel_kromme_lijnen(woordenboek, lettertype):
    """"""
     >>> lettertype = lees_lettertype('lettertype.txt')
    >>> enkel_kromme_lijnen('woordenboek.txt', lettertype)
    {'COCCUS', 'COUSCOUS'}
    """"""
    woorden = []
    boek = open(woordenboek, 'r')
    for regel in boek:
        regel = regel.rstrip()
        totaal = aantal_rechte_lijnen(regel, lettertype)
        if totaal == 0:
            woorden.append(regel)
    return set(woorden)
def gebalanceerde_lijnen(tekst, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> gebalanceerde_lijnen('woordenboek.txt', lettertype)
    {'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}:
    """"""
    woorden = []
    boek = open(tekst, 'r')
    for regel in boek:
        regel = regel.rstrip()
        if aantal_rechte_lijnen(regel, lettertype) == aantal_kromme_lijnen(regel, lettertype):
            woorden.append(regel)
    return set(woorden)",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( string ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( boolean_operator ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( unary_operator ( integer ) ) ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( identifier ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( list ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( list ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( list ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ),109,"{""filename"":""Laura De Fraine/geometrische-letters.py"",""fullName"":""Laura De Fraine"",""id"":""8114"",""status"":""correct"",""submissionID"":""6747301"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T13:43:35.000Z"",""labels"":""bcbt""}"
106,../exam-folder/Benthe Van Buyten/geometrische-letters.py,"""""""
>>> lettertype = lees_lettertype('lettertype.txt')
>>> lettertype['E']
(4, 0)
>>> lettertype['R']
(2, 1)
>>> lettertype['G']
(1, 1)
>>> lettertype['O']
(0, 1)

>>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
21
>>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
4

>>> enkel_rechte_lijnen('woordenboek.txt', lettertype)
{'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
>>> enkel_kromme_lijnen('woordenboek.txt', lettertype)
{'COCCUS', 'COUSCOUS'}
>>> gebalanceerde_lijnen('woordenboek.txt', lettertype)
{'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}
""""""
def lees_lettertype(bestand):
    invoer = open(bestand, 'r')
    dicto = {}
    for regel in invoer.readlines():
        regel = regel.rstrip('\n')
        karakter, rechte, kromme = regel.split()
        dicto[karakter] = (int(rechte), int(kromme))
    return dicto

def aantal_rechte_lijnen(woord, wb):
    som = 0
    for letter in woord:
        if letter.isalpha():
            som += wb[letter][0]
    return som

def aantal_kromme_lijnen(woord, wb):
    som = 0
    for letter in woord:
        if letter.isalpha():
            som += wb[letter][1]
    return som

def enkel_rechte_lijnen(bestand, wb):
    verzameling = set()
    invoer = open(bestand, 'r')
    for regel in invoer.readlines():
        regel = regel.rstrip('\n')
        # kijken of er geen kromme lijnen zijn
        if aantal_kromme_lijnen(regel, wb) == 0:
            verzameling.add(regel)
    return verzameling

def enkel_kromme_lijnen(bestand, wb):
    verzameling = set()
    invoer = open(bestand, 'r')
    for regel in invoer.readlines():
        regel = regel.rstrip('\n')
        # kijken of er geen rechte lijnen zijn
        if aantal_rechte_lijnen(regel, wb) == 0:
            verzameling.add(regel)
    return verzameling

def gebalanceerde_lijnen(bestand, wb):
    verzameling = set()
    invoer = open(bestand, 'r')
    for regel in invoer.readlines():
        regel = regel.rstrip('\n')
        # kijken of de rechte gelijk zijn aan de kromme
        if aantal_rechte_lijnen(regel, wb) == aantal_kromme_lijnen(regel, wb):
            verzameling.add(regel)
    return verzameling",( module ( expression_statement ( string ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( tuple ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),104,"{""filename"":""Benthe Van Buyten/geometrische-letters.py"",""fullName"":""Benthe Van Buyten"",""id"":""8025"",""status"":""correct"",""submissionID"":""6750253"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:02:51.000Z"",""labels"":""bcbt""}"
107,../exam-folder/Arthur Catteuw/geometrische-letters.py,"# functie lees lettertype aanmaken
def lees_lettertype(tekst):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> lettertype['E']
    (4, 0)
    >>> lettertype['R']
    (2, 1)
    >>> lettertype['G']
    (1, 1)
    >>> lettertype['O']
    (0, 1)
    """"""
    # tekst openen
    invoer = open(tekst,'r')

    # dictionary aanmaken
    dict = {}
    for regel in invoer:
        letter, rechten, krommen = regel.rstrip('\n').split(' ')
        dict[letter] = (int(rechten), int(krommen))
    invoer.close()
    return dict

# functie aantal rechte lijnen aanmaken
def aantal_rechte_lijnen(woord, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
    21
    """"""
    # aantal rechte lijnen tellen
    aantal = 0
    for letter in woord:
        if letter.isalpha():
            aantal += lettertype[letter][0]
    return aantal

# functie aantal kromme lijnen aanmaken
def aantal_kromme_lijnen(woord, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
    4
    """"""
    # aantal rechte lijnen tellen
    aantal = 0
    for letter in woord:
        if letter.isalpha():
            aantal += lettertype[letter][1]
    return aantal

# functie enkel rechte lijnen aanmaken
def enkel_rechte_lijnen(tekst, letterype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> enkel_rechte_lijnen('woordenboek.txt', lettertype)
    {'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
    """"""
    # tekst openen
    woorden = open(tekst, 'r')

    # verzameling aanmaken
    verz = set()
    for woord in woorden:
        woord = woord.rstrip('\n')
        if aantal_kromme_lijnen(woord, letterype) == 0:
            verz.add(woord)
    woorden.close()
    return verz

# functie enkel kromme lijnen aanmaken
def enkel_kromme_lijnen(tekst, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> enkel_kromme_lijnen('woordenboek.txt', lettertype)
    {'COCCUS', 'COUSCOUS'}
    """"""
    # tekst openen
    woorden = open(tekst, 'r')

    # verzameling aanmaken
    verz = set()
    for woord in woorden:
        woord = woord.rstrip('\n')
        if aantal_rechte_lijnen(woord, lettertype) == 0:
            verz.add(woord)
    woorden.close()
    return verz

# functie gebalanceerde lijnen aanmaken
def gebalanceerde_lijnen(tekst, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> gebalanceerde_lijnen('woordenboek.txt', lettertype)
    {'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}
    """"""
    # tekst openen
    woorden = open(tekst, 'r')

    # verzameling aanmaken
    verz = set()
    for woord in woorden:
        woord = woord.rstrip('\n')
        if aantal_rechte_lijnen(woord, lettertype) == aantal_kromme_lijnen(woord, lettertype):
            verz.add(woord)
    woorden.close()
    return verz

if __name__ == '__main__':
    import doctest
    doctest.testmod()",( module ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( tuple ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( identifier ) ) ) ) ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( identifier ) ) ) ) ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( identifier ) ) ) ) ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( identifier ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),121,"{""filename"":""Arthur Catteuw/geometrische-letters.py"",""fullName"":""Arthur Catteuw"",""id"":""11552"",""status"":""correct"",""submissionID"":""6748710"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:23:15.000Z"",""labels"":""geog""}"
108,../exam-folder/Hannah De Cock/geometrische-letters.py,"def lees_lettertype(locatie):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> lettertype['E']
    (4, 0)
    >>> lettertype['R']
    (2, 1)
    >>> lettertype['G']
    (1, 1)
    >>> lettertype['O']
    (0, 1)
    """"""
    tekst = open(locatie)
    lettertype = {}
    # regel splitsen om dictionary elementen te ontleden
    for regel in tekst:
        # '\n' moet verwijderd worden
        regel = regel[:-1].split(' ')
        lettertype[regel[0]] = (int(regel[1]), int(regel[2]))

    return lettertype

def aantal_rechte_lijnen(woord, lettertype):
    """"""
    >>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
    21
    """"""
    aantal = 0
    for letter in woord:
        # enkel lijnen tellen als het teken een letter is
        if letter.isalpha():
            aantal += lettertype[letter][0]

    return aantal

def aantal_kromme_lijnen(woord, lettertype):
    """"""
    >>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
    4
    """"""
    aantal = 0
    for letter in woord:
        # enkel lijnen tellen als het teken een letter is
        if letter.isalpha():
            aantal += lettertype[letter][1]

    return aantal

def enkel_rechte_lijnen(locatie, lettertype):
    """"""
    >>> enkel_rechte_lijnen('woordenboek.txt', lettertype)
    {'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
    """"""
    tekst = open(locatie)
    verz = set()
    for woord in tekst:
        # '\n' moet verwijderd worden
        woord = woord[:-1]
        # er zijn enkel rechte lijnen als aantal kromme lijnen = 0
        if aantal_kromme_lijnen(woord, lettertype) == 0:
            verz.add(woord)

    return verz

def enkel_kromme_lijnen(locatie, lettertype):
    """"""
    >>> enkel_kromme_lijnen('woordenboek.txt', lettertype)
    {'COCCUS', 'COUSCOUS'}
    """"""
    tekst = open(locatie)
    verz = set()
    for woord in tekst:
        # '\n' moet verwijderd worden
        woord = woord[:-1]
        # er zijn enkel kromme lijnen als aantal rechte lijnen = 0
        if aantal_rechte_lijnen(woord, lettertype) == 0:
            verz.add(woord)

    return verz

def gebalanceerde_lijnen(locatie, lettertype):
    """"""
    >>> gebalanceerde_lijnen('woordenboek.txt', lettertype)
    {'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}
    """"""
    tekst = open(locatie)
    verz = set()
    for woord in tekst:
        # '\n' moet verwijderd worden
        woord = woord[:-1]
        # aantallen gelijk stellen
        if aantal_rechte_lijnen(woord, lettertype) == aantal_kromme_lijnen(woord, lettertype):
            verz.add(woord)

    return verz

if __name__ == '__main__':
    import doctest
    doctest.testmod()",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),114,"{""filename"":""Hannah De Cock/geometrische-letters.py"",""fullName"":""Hannah De Cock"",""id"":""11554"",""status"":""correct"",""submissionID"":""6749900"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:52:57.000Z"",""labels"":""geog""}"
109,../exam-folder/Vic De Ridder/geometrische-letters.py,"#On variable naming:
#   ""name"" always refers to the name of the document that has to be read
#   ""dic"" is short for dictionary

def read_font(name):
    dic = {}
    for line in open(name, ""r""):
        line = line.split()
        dic[line[0]] = (int(line[1]), int(line[2]))
    return dic


def count_straight_lines(word, dic):
    count = 0
    for char in word:
        if char in dic.keys():
            count += dic[char][0]
    return count


def count_curved_lines(word, dic):
    count = 0
    for char in word:
        if char in dic.keys():
            count += dic[char][1]
    return count

#The following functions all follow the same structure, only differing in the condition under which a line is added

def straight_lines_only(name, dic):
    setofwords = set()
    for line in open(name, ""r""):
        line = line.rstrip() #.rstrip() is used to avoid the \n with which each line ends, idem in all other functions below
        if count_curved_lines(line, dic) == 0:
            setofwords.add(line)
    return setofwords


def curved_lines_only(name, dic):
    setofwords = set()
    for line in open(name, ""r""):
        line = line.rstrip()
        if count_straight_lines(line, dic) == 0:
            setofwords.add(line)
    return setofwords


def balanced_lines(name, dic):
    setofwords = set()
    for line in open(name, ""r""):
        line = line.rstrip()
        if count_straight_lines(line, dic) == count_curved_lines(line, dic):
            setofwords.add(line)
    return setofwords
",( module ( comment ) ( comment ) ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),79,"{""filename"":""Vic De Ridder/geometrische-letters.py"",""fullName"":""Vic De Ridder"",""id"":""11625"",""status"":""correct"",""submissionID"":""6748459"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:18:05.000Z"",""labels"":""fyss""}"
110,../exam-folder/Arno Foucher/geometrische-letters.py,"def lees_lettertype(file):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> lettertype['E']
    (4, 0)
    >>> lettertype['R']
    (2, 1)
    >>> lettertype['G']
    (1, 1)
    >>> lettertype['O']
    (0, 1)

    >>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
    21
    >>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
    4

    >>> enkel_rechte_lijnen('woordenboek.txt', lettertype)
    {'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
    >>> enkel_kromme_lijnen('woordenboek.txt', lettertype)
    {'COCCUS', 'COUSCOUS'}
    >>> gebalanceerde_lijnen('woordenboek.txt', lettertype)
    {'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}
    """"""
    d = {}
    with open(file, 'r+') as f:
        for line in f:
            key, val1, val2 = line.split(' ')
            d[(key)] = (int(val1), int(val2.strip()))
        return d

def aantal_rechte_lijnen(woord, dict):
    getal = 0
    for letter in woord:
        if letter.isalpha():
            combo = dict[letter]
            getal += combo[0]
    return getal

def aantal_kromme_lijnen(woord, dict):
    invers_woordenboek = {k: v[::-1] for k, v in dict.items()}
    return aantal_rechte_lijnen(woord, invers_woordenboek)

def enkel_rechte_lijnen(file, dict):
    verzameling = set()
    with open(file, 'r+') as f:
        for woord in f:
            woord = woord.strip()
            waarde = aantal_kromme_lijnen(woord, dict)
            if waarde == 0:
                verzameling.add(woord)
        return verzameling

def enkel_kromme_lijnen(file, dict):
    verzameling = set()
    with open(file, 'r+') as f:
        for woord in f:
            woord = woord.strip()
            waarde = aantal_rechte_lijnen(woord, dict)
            if waarde == 0:
                verzameling.add(woord)
        return verzameling

def gebalanceerde_lijnen(file, dict):
    groep = set()
    with open(file, 'r+') as f:
        for line in f:
            line = line.strip()
            recht, krom = aantal_rechte_lijnen(line, dict), aantal_kromme_lijnen(line, dict)
            if recht == krom:
                groep.add(line)
        return groep

if __name__ == '__main__':
    import doctest
    doctest.testmod()",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( parenthesized_expression ( identifier ) ) ) ( tuple ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( identifier ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary_comprehension ( pair ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ( for_in_clause ( pattern_list ( identifier ) ( identifier ) ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( expression_list ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),107,"{""filename"":""Arno Foucher/geometrische-letters.py"",""fullName"":""Arno Foucher"",""id"":""8373"",""status"":""correct"",""submissionID"":""6747627"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T13:53:36.000Z"",""labels"":""bcbt""}"
111,../exam-folder/Niko Strijbol/geometrische-letters.py,"# https://dodona.ugent.be/nl/courses/359/series/4282/activities/1522917022


def lees_lettertype(locatie):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> lettertype['E']
    (4, 0)
    >>> lettertype['R']
    (2, 1)
    >>> lettertype['G']
    (1, 1)
    >>> lettertype['O']
    (0, 1)
    """"""
    with open(locatie, ""r"") as bestand:
        resultaat = {}
        for regel in bestand:
            letter, rechten, krommen = regel.split("" "")
            resultaat[letter] = (int(rechten), int(krommen))
    return resultaat


def aantal_lijnen(woord, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> aantal_lijnen('ERGONOMIE', lettertype)
    (21, 4)
    >>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
    21
    >>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
    4
    """"""
    r = 0
    k = 0
    for letter in woord:
        (rechten, krommen) = lettertype.get(letter, (0, 0))
        r += rechten
        k += krommen
    return r, k


def aantal_rechte_lijnen(woord, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> aantal_lijnen('ERGONOMIE', lettertype)
    (21, 4)
    >>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
    21
    >>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
    4
    """"""
    return aantal_lijnen(woord, lettertype)[0]


def aantal_kromme_lijnen(woord, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> aantal_lijnen('ERGONOMIE', lettertype)
    (21, 4)
    >>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
    21
    >>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
    4
    """"""
    return aantal_lijnen(woord, lettertype)[1]


def groepeer_lijnen(locatie, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> enkel_rechte_lijnen('woordenboek.txt', lettertype)
    {'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
    >>> enkel_kromme_lijnen('woordenboek.txt', lettertype)
    {'COCCUS', 'COUSCOUS'}
    >>> gebalanceerde_lijnen('woordenboek.txt', lettertype)
    {'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}
    """"""
    rs = set()
    ks = set()
    gs = set()
    with open(locatie, ""r"") as bestand:
        for woord in bestand:
            woord = woord.strip()
            r, k = aantal_lijnen(woord, lettertype)
            if r == 0:
                rs.add(woord)
            if k == 0:
                ks.add(woord)
            if k == r:
                gs.add(woord)
    return rs, ks, gs


def enkel_rechte_lijnen(locatie, lettertype):
    return groepeer_lijnen(locatie, lettertype)[1]


def enkel_kromme_lijnen(locatie, lettertype):
    return groepeer_lijnen(locatie, lettertype)[0]


def gebalanceerde_lijnen(locatie, lettertype):
    return groepeer_lijnen(locatie, lettertype)[2]
",( module ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( string ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( tuple ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( tuple_pattern ( identifier ) ( identifier ) ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ( tuple ( integer ) ( integer ) ) ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ( return_statement ( expression_list ( identifier ) ( identifier ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( expression_list ( identifier ) ( identifier ) ( identifier ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ),85,"{""filename"":""Niko Strijbol/geometrische-letters.py"",""fullName"":""Niko Strijbol"",""id"":""824"",""status"":""correct"",""submissionID"":""6741785"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-13T20:02:39.000Z"",""labels"":""admin""}"
112,../exam-folder/Saskia Proumen De Keyser/geometrische-letters.py,"""""""
>>> font = read_font('font.txt')
>>> font['E']
(4, 0)
>>> font['R']
(2, 1)
>>> font['G']
(1, 1)
>>> font['O']
(0, 1)

>>> line_count('ERGONOMICS', font)
(17, 6)
>>> count_straight_lines('ERGONOMICS', font)
17
>>> count_curved_lines('ERGONOMICS', font)
6

>>> straight_lines_only('dictionary.txt', font) == {'ALKALINE', 'MILLENNIAL', 'INFINITELY'}
True
>>> curved_lines_only('dictionary.txt', font) == {'COCCUS', 'COUSCOUS'}
True
>>> balanced_lines('dictionary.txt', font) == {'AUGUSTUS', 'CROSSROAD', 'SUDOKU', 'COLUMBUS', 'PROCESSORS'}
True
""""""


def read_font(filename):
    # make a dictionary of the characters
    dict_characters = {}

    # maps each character in the file onto a tuple with the number of straight lines
    # and the number of curved lines
    with open(filename, 'r') as file:
        for line in file:
            letter, straight, curved = line.rstrip('\n').split(' ')
            dict_characters[letter] = (int(straight), int(curved))

    return dict_characters


def count_straight_lines(word, font):
    count = 0

    for letter in word:
        if letter in font:                  # to avoid KeyError
            count += font[letter][0]        # only the straight lines

    return count


def count_curved_lines(word, font):
    count = 0

    for letter in word:
        if letter in font:            # to avoid KeyError
            count += font[letter][1]  # only the curved lines

    return count


def straight_lines_only(filename, font):
    # make a set with the words which only contain straight lines
    words = set()

    with open(filename, 'r') as file:
        for word in file:
            word = word.rstrip('\n')                    # get rid of the '\n'
            if count_curved_lines(word, font) == 0:     # only straight lines
                words.add(word)

    return words


def curved_lines_only(filename, font):
    # make a set with the words which only contain curved lines
    words = set()

    with open(filename, 'r') as file:
        for word in file:
            word = word.rstrip('\n')                    # get rid of the '\n'
            if count_straight_lines(word, font) == 0:   # only curved lines
                words.add(word)

    return words


def balanced_lines(filename, font):
    # make a set with the words that are written with and equal number of straight and curved lines in the font
    words = set()

    with open(filename, 'r') as file:
        for word in file:
            word = word.rstrip('\n')                                                # get rid of the '\n'
            if count_straight_lines(word, font) == count_curved_lines(word, font):  # even number of straight
                words.add(word)                                                     # and curved lines

    return words


def line_count(word, font):
    return count_straight_lines(word, font), count_curved_lines(word, font)


if __name__ == '__main__':
    import doctest
    doctest.testmod()
",( module ( expression_statement ( string ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( comment ) ( comment ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( tuple ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ( comment ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( comment ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ( comment ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( expression_list ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),109,"{""filename"":""Saskia Proumen De Keyser/geometrische-letters.py"",""fullName"":""Saskia Proumen De Keyser"",""id"":""11649"",""status"":""correct"",""submissionID"":""6750205"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:01:24.000Z"",""labels"":""biol""}"
113,../exam-folder/Manon Van Goethem/geometrische-letters.py,"def lees_lettertype(tekstbestand):
    invoer = open(tekstbestand)
    data = invoer.read()
    plaats = data.find(tekstbestand)
    return plaats
    ",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),8,"{""filename"":""Manon Van Goethem/geometrische-letters.py"",""fullName"":""Manon Van Goethem"",""id"":""11651"",""status"":""runtime error"",""submissionID"":""6749801"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:50:23.000Z"",""labels"":""chem""}"
114,../exam-folder/Jorg Wieme/geometrische-letters.py,"# https://dodona.ugent.be/nl/courses/359/series/4282/activities/1522917022

def lees_lettertype(filename):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> lettertype['E']
    (4, 0)
    >>> lettertype['R']
    (2, 1)
    >>> lettertype['G']
    (1, 1)
    >>> lettertype['O']
    (0, 1)
    """"""
    result = dict()
    for line in open(filename, 'r'):
        line = line.strip('\n').split(' ')
        result[line[0]] = (int(line[1]), int(line[2]))
    return result


def aantal_rechte_lijnen(woord, vertalling):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
    21
    """"""
    return sum(vertalling[l][0] for l in woord if l.isalpha())


def aantal_kromme_lijnen(woord, vertalling):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
    4
    """"""
    return sum(vertalling[l][1] for l in woord if l.isalpha())


def enkel_rechte_lijnen(filename, vertalling):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> enkel_rechte_lijnen('woordenboek.txt', lettertype)
    {'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
    """"""
    return {x.strip('\n') for x in open(filename, 'r') if aantal_kromme_lijnen(x.strip('\n'), vertalling) == 0}


def enkel_kromme_lijnen(filename, vertalling):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> enkel_kromme_lijnen('woordenboek.txt', lettertype)
    {'COCCUS', 'COUSCOUS'}
    """"""
    return {x.strip('\n') for x in open(filename, 'r') if aantal_rechte_lijnen(x.strip('\n'), vertalling) == 0}


def gebalanceerde_lijnen(filename, vertalling):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> gebalanceerde_lijnen('woordenboek.txt', lettertype)
    {'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}
    """"""
    return {x.strip('\n') for x in open(filename, 'r') if
            aantal_kromme_lijnen(x.strip('\n'), vertalling) == aantal_rechte_lijnen(x.strip('\n'), vertalling)}
",( module ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( return_statement ( call ( identifier ) ( generator_expression ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( return_statement ( call ( identifier ) ( generator_expression ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( for_in_clause ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ( if_clause ( comparison_operator ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ) ( integer ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( for_in_clause ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ( if_clause ( comparison_operator ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ) ( integer ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( for_in_clause ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ( if_clause ( comparison_operator ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ) ) ) ) ) ) ) ),76,"{""filename"":""Jorg Wieme/geometrische-letters.py"",""fullName"":""Jorg Wieme"",""id"":""1046"",""status"":""correct"",""submissionID"":""6743222"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T01:29:49.000Z"",""labels"":""admin""}"
115,../exam-folder/Oliver Urs Lenz/geometrische-letters.py,"# https://dodona.ugent.be/nl/courses/359/series/4282/activities/1522917022


def lees_lettertype(locatie: str):
    with open(locatie, 'r') as f:
        tabel = f.read()
    beschrijving = {}
    for r in tabel.splitlines():
        l, recht, krom = r.split()
        beschrijving[l] = (int(recht), int(krom))
    return beschrijving


def aantal_rechte_lijnen(w: str, beschrijving) -> int:
    return sum(beschrijving.get(l, (0, 0))[0] for l in w)


def aantal_kromme_lijnen(w: str, beschrijving) -> int:
    return sum(beschrijving.get(l, (0, 0))[1] for l in w)


def lees_woorden(locatie: str):
    with open(locatie, 'r') as f:
        return f.read().splitlines()


def enkel_rechte_lijnen(locatie: str, beschrijving):
    antwoord = set()
    for w in lees_woorden(locatie):
        if aantal_kromme_lijnen(w, beschrijving) == 0:
            antwoord.add(w)
    return antwoord


def enkel_kromme_lijnen(locatie: str, beschrijving):
    antwoord = set()
    for w in lees_woorden(locatie):
        if aantal_rechte_lijnen(w, beschrijving) == 0:
            antwoord.add(w)
    return antwoord


def gebalanceerde_lijnen(locatie: str, beschrijving):
    antwoord = set()
    for w in lees_woorden(locatie):
        if aantal_kromme_lijnen(w, beschrijving) == aantal_rechte_lijnen(w, beschrijving):
            antwoord.add(w)
    return antwoord


",( module ( comment ) ( function_definition ( identifier ) ( parameters ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ) ( block ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( tuple ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ( identifier ) ) ( type ( identifier ) ) ( block ( return_statement ( call ( identifier ) ( generator_expression ( subscript ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ( tuple ( integer ) ( integer ) ) ) ) ( integer ) ) ( for_in_clause ( identifier ) ( identifier ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ( identifier ) ) ( type ( identifier ) ) ( block ( return_statement ( call ( identifier ) ( generator_expression ( subscript ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ( tuple ( integer ) ( integer ) ) ) ) ( integer ) ) ( for_in_clause ( identifier ) ( identifier ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ) ( block ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( return_statement ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),89,"{""filename"":""Oliver Urs Lenz/geometrische-letters.py"",""fullName"":""Oliver Urs Lenz"",""id"":""11652"",""status"":""correct"",""submissionID"":""6741795"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-13T20:03:38.000Z"",""labels"":""admin""}"
116,../exam-folder/Bert Van Hecke/geometrische-letters.py,"def lees_lettertype(locatie):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> lettertype['E']
    (4, 0)
    >>> lettertype['R']
    (2, 1)
    >>> lettertype['G']
    (1, 1)
    >>> lettertype['O']
    (0, 1)
    """"""
    letterboek = {}
    for regel in open(locatie, ""r""):
        letter, recht, krom = regel.split()
        letterboek[letter] = (int(recht), int(krom))
    return letterboek


def aantal_lijnen(woord, beschrijving):
    rechte_lijnen, kromme_lijnen = 0, 0
    for letter in woord:
        if letter in beschrijving:
            rechte, kromme = beschrijving[letter]
            rechte_lijnen += rechte
            kromme_lijnen += kromme
    return rechte_lijnen, kromme_lijnen


def aantal_rechte_lijnen(woord, beschrijving):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
    21
    """"""
    return aantal_lijnen(woord, beschrijving)[0]


def aantal_kromme_lijnen(woord, beschrijving):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
    4
    """"""
    return aantal_lijnen(woord, beschrijving)[1]


def enkel_rechte_lijnen(locatie, beschrijving):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> enkel_rechte_lijnen('woordenboek.txt', lettertype)
    {'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
    """"""
    return {regel.rstrip() for regel in open(locatie, ""r"") if not aantal_kromme_lijnen(regel.rstrip(), beschrijving)}


def enkel_kromme_lijnen(locatie, beschrijving):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> enkel_kromme_lijnen('woordenboek.txt', lettertype)
    {'COCCUS', 'COUSCOUS'}
    """"""
    return {regel.rstrip() for regel in open(locatie, ""r"") if not aantal_rechte_lijnen(regel.rstrip(), beschrijving)}


def gebalanceerde_lijnen(locatie, beschrijving):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> gebalanceerde_lijnen('woordenboek.txt', lettertype)
    {'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}
    """"""
    return {regel.rstrip() for regel in open(locatie, ""r"")
            if aantal_rechte_lijnen(regel.rstrip(), beschrijving) == aantal_kromme_lijnen(regel.rstrip(), beschrijving)}


if __name__ == '__main__':
    import doctest
    doctest.testmod()
",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( tuple ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( expression_list ( integer ) ( integer ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( subscript ( identifier ) ( identifier ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ( return_statement ( expression_list ( identifier ) ( identifier ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( for_in_clause ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ( if_clause ( not_operator ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( for_in_clause ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ( if_clause ( not_operator ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( for_in_clause ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ( if_clause ( comparison_operator ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ) ) ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),96,"{""filename"":""Bert Van Hecke/geometrische-letters.py"",""fullName"":""Bert Van Hecke"",""id"":""7924"",""status"":""correct"",""submissionID"":""6745239"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T11:11:45.000Z"",""labels"":""admin""}"
117,../exam-folder/Sabina Shamieva/geometrische-letters.py,"def lees_lettertype(locatie):
    data = open(locatie, 'r').readlines()
    dictio = {}
    for regel in data:  # itereren over de regels in het bestand
        regel = regel.split(' ')  # regel splitten over 3 elementen
        letter = regel[0]
        rechte = int(regel[1])
        kromme = int(regel[2].replace('\n', ''))
        dictio[letter] = (rechte, kromme)  # key = letter en value = tuple van integers
    return dictio

def aantal_rechte_lijnen(woord, beschrijving):
    rechte = 0
    for letter in woord:  # itereren over de letters
        if letter in beschrijving:  # indien de letter in bestand
            rechte += beschrijving[letter][0]  # eerste element van de tuple
    return rechte

def aantal_kromme_lijnen(woord, beschrijving):
    kromme = 0
    for letter in woord:
        if letter in beschrijving:
            kromme += beschrijving[letter][1]  # de tweede element van de tuple
    return kromme


def enkel_rechte_lijnen(locatie_woorden, beschrijving):
    data = open(locatie_woorden, 'r').read().split('\n')
    set0 = set()
    for woord in data[:-1]:  # woorden uit het bestand halen
        if aantal_kromme_lijnen(woord, beschrijving) == 0:  # kromme moet nul zijn
            set0.add(woord)  # woord toevoegen aan de set
    return set0

def enkel_kromme_lijnen(locatie_woorden, beschrijving):
    data = open(locatie_woorden, 'r').read().split('\n')
    set0 = set()
    for woord in data[:-1]:  # woorden uit het bestand halen
        if aantal_rechte_lijnen(woord, beschrijving) == 0:  # rechte lijnen moeten nul zijn
            set0.add(woord)  # woord toevoegen aan de set
    return set0

def gebalanceerde_lijnen(locatie_woorden, beschrijving):
    data = open(locatie_woorden, 'r').read().split('\n')  # openen, lezen het bestand, splitten elke lijn in elementen van lijst
    set0 = set()
    for woord in data[:-1]:  # woorden uit het bestand halen
        if aantal_rechte_lijnen(woord, beschrijving) == aantal_kromme_lijnen(woord, beschrijving):  # rechte lijnen moeten gelijk zijn aan kromme lijnen
            set0.add(woord)  # woord toevoegen aan de set
    return set0",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( call ( attribute ( subscript ( identifier ) ( integer ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ( string ) ) ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( tuple ( identifier ) ( identifier ) ) ) ) ( comment ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ( comment ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ( comment ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ( comment ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),102,"{""filename"":""Sabina Shamieva/geometrische-letters.py"",""fullName"":""Sabina Shamieva"",""id"":""11654"",""status"":""correct"",""submissionID"":""6749032"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:31:08.000Z"",""labels"":""bcbt""}"
118,../exam-folder/Dnegl Sahin/geometrische-letters.py,"# gescheiden door spatie
# eerste = karakter
# tweede = aantal rechte lijnen
# derde = aantal kromme lijnen

def lees_lettertype(tekstbestand):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> lettertype['E']
    (4, 0)
    >>> lettertype['R']
    (2, 1)
    >>> lettertype['G']
    (1, 1)
    >>> lettertype['O']
    (0, 1)
    """"""
    lettertype = dict()
    for line in open(tekstbestand).readlines():
        line = line.rstrip('\n')
        lijst = line.split(' ')
        letter, aantal_rechte, aantal_kromme = lijst[0], lijst[1], lijst[2]
        lettertype[letter] = tuple([int(aantal_rechte), int(aantal_kromme)])
    return lettertype

def aantal_rechte_lijnen(woord, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
    21
    """"""
    aantal_rechte = 0
    for letter in woord:
        if letter.isalpha():
            koppel = list(lettertype.get(letter))
            aantal_rechte += koppel[0]
    return aantal_rechte

def aantal_kromme_lijnen(woord, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
    4
    """"""
    aantal_kromme = 0
    for letter in woord:
        if letter.isalpha():
            koppel = list(lettertype.get(letter))
            aantal_kromme += koppel[1]
    return aantal_kromme

def enkel_rechte_lijnen(tekstbestand, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> enkel_rechte_lijnen('woordenboek.txt', lettertype)
    {'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
    """"""
    verzameling = set()
    for woord in open(tekstbestand).readlines():
        woord = woord.rstrip('\n')
        if aantal_kromme_lijnen(woord, lettertype) == 0:
            verzameling.add(woord)
    return verzameling

def enkel_kromme_lijnen(tekstbestand, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> enkel_kromme_lijnen('woordenboek.txt', lettertype)
    {'COCCUS', 'COUSCOUS'}
    """"""
    verzameling = set()
    for woord in open(tekstbestand).readlines():
        woord = woord.rstrip('\n')
        if aantal_rechte_lijnen(woord, lettertype) == 0:
            verzameling.add(woord)
    return verzameling

def gebalanceerde_lijnen(tekstbestand, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> gebalanceerde_lijnen('woordenboek.txt', lettertype)
    {'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}
    """"""
    verzameling = set()
    for woord in open(tekstbestand).readlines():
        woord = woord.rstrip('\n')
        if aantal_rechte_lijnen(woord, lettertype) == aantal_kromme_lijnen(woord, lettertype):
            verzameling.add(woord)
    return verzameling
",( module ( comment ) ( comment ) ( comment ) ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( attribute ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( expression_list ( subscript ( identifier ) ( integer ) ) ( subscript ( identifier ) ( integer ) ) ( subscript ( identifier ) ( integer ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( call ( identifier ) ( argument_list ( list ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( attribute ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( attribute ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( attribute ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),106,"{""filename"":""Dnegl Sahin/geometrische-letters.py"",""fullName"":""Dnegl Sahin"",""id"":""7988"",""status"":""correct"",""submissionID"":""6750540"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:11:34.000Z"",""labels"":""bcbt""}"
119,../exam-folder/Sarah Gentenaar/geometrische-letters.py,"def read_font(location):
    d = {}
    with open(location) as f:
        for line in f:
            (key, val1, val2) = line.split()
            d[key] = (int(val1), int(val2))
    return d
    
def count_straight_lines(word, font):
    count = 0
    for c in word:
        count += font[c][0]
    return count

def count_curved_lines(word, font):
    count = 0
    for c in word:
        count += font[c][1]
    return count",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( tuple_pattern ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( tuple ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),28,"{""filename"":""Sarah Gentenaar/geometrische-letters.py"",""fullName"":""Sarah Gentenaar"",""id"":""11684"",""status"":""runtime error"",""submissionID"":""6750510"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:10:33.000Z"",""labels"":""keuz""}"
120,../exam-folder/Anouk Van genechten/geometrische-letters.py,"import string


def read_font(location):

    """"""
    return a dictionary (dict) that maps each character (str) in the file onto a tuple with the number of straight
    lines (int) and the number of curved lines (int) in the character.

    >>> font = read_font('font.txt')
    >>> font['E']
    (4, 0)
    >>> font['R']
    (2, 1)
    >>> font['G']
    (1, 1)
    >>> font['O']
    (0, 1)
    """"""

    dic = {}

    with open(location, 'r') as font:
        for line in font:
            characters = line.rstrip('\n').split()
            dic[characters[0]] = int(characters[1]), int(characters[2])

    return dic


def line_count(word, font):

    """"""
    >>> font = read_font('font.txt')
    >>> line_count('ERGONOMICS', font)
    (17, 6)
    """"""

    # split the word in letter and make the sum of the straight lines and the curved lines
    total_straight, total_curved = 0, 0

    for letter in word:
        if letter in string.ascii_letters:
            lines = font[letter]
            total_straight += lines[0]
            total_curved += lines[1]

    return total_straight, total_curved


def count_straight_lines(word, font):

    """"""
    >>> font = read_font('font.txt')
    >>> count_straight_lines('ERGONOMICS', font)
    17
    """"""

    # take the first answer of line_count
    return line_count(word, font)[0]


def count_curved_lines(word, font):

    """"""
    >>> font = read_font('font.txt')
    >>> count_curved_lines('ERGONOMICS', font)
    6
    """"""

    # take the second answer of line_count
    return line_count(word, font)[1]


def straight_curved_equal(location, font):

    # make a set for each situation
    words_straight_only = set()
    words_curved_only = set()
    words_balanced = set()

    # open the dictionary
    with open(location, 'r') as dictionary:
        for word in dictionary:
            word = word.rstrip('\n')

            # count straight and curved lines
            curved = count_curved_lines(word, font)
            straight = count_straight_lines(word, font)

            # add the words to the right set
            if curved == 0:
                words_straight_only.add(word)
            elif straight == 0:
                words_curved_only.add(word)
            elif curved == straight:
                words_balanced.add(word)

    return words_straight_only, words_curved_only, words_balanced


def straight_lines_only(location, font):

    """"""
    >>> font = read_font('font.txt')
    >>> straight_lines_only('dictionary.txt', font)
    {'ALKALINE', 'MILLENNIAL', 'INFINITELY'}
    """"""

    # return the first answer of str_curved_equal
    return straight_curved_equal(location, font)[0]


def curved_lines_only(location, font):

    """"""
    >>> font = read_font('font.txt')
    >>> curved_lines_only('dictionary.txt', font)
    {'COCCUS', 'COUSCOUS'}
    """"""

    # return the second answer of str_curved_equal
    return straight_curved_equal(location, font)[1]


def balanced_lines(location, font):

    """"""
    >>> font = read_font('font.txt')
    >>> balanced_lines('dictionary.txt', font)
    {'AUGUSTUS', 'CROSSROAD', 'SUDOKU', 'COLUMBUS', 'PROCESSORS'}
    """"""

    # return the third answer of str_curved_equal
    return straight_curved_equal(location, font)[2]


if __name__ == '__main__':
    import doctest
    doctest.testmod()
",( module ( import_statement ( dotted_name ( identifier ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( expression_list ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( expression_list ( integer ) ( integer ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( attribute ( identifier ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( identifier ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( expression_list ( identifier ) ( identifier ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ( elif_clause ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( elif_clause ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( expression_list ( identifier ) ( identifier ) ( identifier ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),109,"{""filename"":""Anouk Van genechten/geometrische-letters.py"",""fullName"":""Anouk Van genechten"",""id"":""11710"",""status"":""correct"",""submissionID"":""6749979"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:55:19.000Z"",""labels"":""keuz""}"
121,../exam-folder/Wim Devis/geometrische-letters.py,"def lees_lettertype(naam):
    bestand = open(naam, ""r"")
    lijnen = bestand.readlines()
    aantal = len(lijnen)

    dicto = dict()
    for i in range(aantal):
        letter, waarde_1, waarde_2 = lijnen[i].split(' ')
        dicto[letter] = (int(waarde_1), int(waarde_2[:-1]))
    return dicto


def aantal_rechte_lijnen(woord, dicto):
    som = 0
    for letter in woord:
        if letter.isalpha():
            som += dicto[letter][0]
    return som


def aantal_kromme_lijnen(woord, dicto):
    som = 0
    for letter in woord:
        if letter.isalpha():
            som += dicto[letter][1]
    return som


def enkel_rechte_lijnen(naam, dicto):
    bestand = open(naam, ""r"")
    lijnen = bestand.readlines()
    aantal = len(lijnen)

    rechte_lijnen = list()
    for i in range(aantal):
        if aantal_kromme_lijnen(lijnen[i][:-1], dicto) == 0:
            rechte_lijnen.append(lijnen[i][:-1])
    return set(rechte_lijnen)


def enkel_kromme_lijnen(naam, dicto):
    bestand = open(naam, ""r"")
    lijnen = bestand.readlines()
    aantal = len(lijnen)

    kromme_lijnen = list()
    for i in range(aantal):
        if aantal_rechte_lijnen(lijnen[i][:-1], dicto) == 0:
            kromme_lijnen.append(lijnen[i][:-1])
    return set(kromme_lijnen)


def gebalanceerde_lijnen(naam, dicto):
    bestand = open(naam, ""r"")
    lijnen = bestand.readlines()
    aantal = len(lijnen)

    gebalanceerd = list()
    for i in range(aantal):
        if aantal_rechte_lijnen(lijnen[i][:-1], dicto) == aantal_kromme_lijnen(lijnen[i][:-1], dicto):
            gebalanceerd.append(lijnen[i][:-1])
    return set(gebalanceerd)",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( subscript ( identifier ) ( identifier ) ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( tuple ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( subscript ( subscript ( identifier ) ( identifier ) ) ( slice ( unary_operator ( integer ) ) ) ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( subscript ( subscript ( identifier ) ( identifier ) ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( subscript ( subscript ( identifier ) ( identifier ) ) ( slice ( unary_operator ( integer ) ) ) ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( subscript ( subscript ( identifier ) ( identifier ) ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( subscript ( subscript ( identifier ) ( identifier ) ) ( slice ( unary_operator ( integer ) ) ) ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( subscript ( subscript ( identifier ) ( identifier ) ) ( slice ( unary_operator ( integer ) ) ) ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( subscript ( subscript ( identifier ) ( identifier ) ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ),116,"{""filename"":""Wim Devis/geometrische-letters.py"",""fullName"":""Wim Devis"",""id"":""8106"",""status"":""correct"",""submissionID"":""6750525"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:11:09.000Z"",""labels"":""fyss""}"
122,../exam-folder/Izaak Van Evercooren/geometrische-letters.py,"def read_font(file):
    """"""
    >>> font = read_font('C:/Users/Izaak/font.txt')
    >>> font['E']
    (4, 0)
    >>> font['R']
    (2, 1)
    >>> font['G']
    (1, 1)
    >>> font['O']
    (0, 1)
    """"""
    # Make connection with file.
    reader = open(file, ""r"")

    # Create dictionary which associates each letter of the file with its corresponding number of straight and
    # curved lines.
    word_number_of_lines_dict = dict()
    for line in reader:
        line = line.rstrip(""\n"")
        # Convert line to list.
        line = line.split("" "")
        word_number_of_lines_dict[line[0]] = (int(line[1]), int(line[2]))

    # close file connection
    reader.close()

    # return dictionary
    return word_number_of_lines_dict


def count_straight_lines(word, font_description_dict):
    """"""
    >>> font = read_font('C:/Users/Izaak/font.txt')
    >>> count_straight_lines('ERGONOMICS', font)
    17
    """"""
    # Create variable to store total number of straight lines in the word.
    total_number_straight_lines = 0

    # Count the number of straight lines.
    for letter in word:
        total_number_straight_lines += font_description_dict[letter][0]

    return total_number_straight_lines


def count_curved_lines(word, font_description_dict):
    """"""
    >>> font = read_font('C:/Users/Izaak/font.txt')
    >>> count_curved_lines('ERGONOMICS', font)
    6
    """"""
    # Create variable to store the total number of curved lines in the word.
    total_number_curved_lines = 0

    # Count the number of curved lines.
    for letter in word:
        total_number_curved_lines += font_description_dict[letter][1]

    return total_number_curved_lines


def straight_lines_only(words_file, font_description_dict):
    """"""
    >>> font = read_font('C:/Users/Izaak/font.txt')
    >>> variable = straight_lines_only('C:/Users/Izaak/dictionary.txt', font)
    >>> variable == {'ALKALINE', 'MILLENNIAL', 'INFINITELY'}
    True
    """"""
    # Make connection with the file.
    reader = open(words_file, ""r"")

    # Generate set to store all words without curved lines.
    words_without_curves = set()

    # Isolate words without curved lines
    for line in reader:
        line = line.rstrip()
        if count_curved_lines(line, font_description_dict) == 0:
            words_without_curves.add(line)

    reader.close()
    return words_without_curves


def curved_lines_only(words_file, font_description_dict):
    """"""
    >>> font = read_font('C:/Users/Izaak/font.txt')
    >>> variable = curved_lines_only('C:/Users/Izaak/dictionary.txt', font)
    >>> variable == {'COCCUS', 'COUSCOUS'}
    True
    """"""
    reader = open(words_file, ""r"")

    # Create set to store all words without straight lines
    words_without_straight = set()

    # Isolate all words without straight lines.
    for line in reader:
        line = line.rstrip(""\n"")
        if count_straight_lines(line, font_description_dict) == 0:
            words_without_straight.add(line)

    reader.close()
    return words_without_straight


def balanced_lines(words_file, font_description_dict):
    """"""
    >>> font = read_font('C:/Users/Izaak/font.txt')
    >>> variable = balanced_lines('C:/Users/Izaak/dictionary.txt', font)
    >>> variable == {'AUGUSTUS', 'CROSSROAD', 'SUDOKU', 'COLUMBUS', 'PROCESSORS'}
    True
    """"""

    reader = open(words_file, ""r"")

    # Create set to store all balanced words.
    balanced_words = set()

    # Isolate all balanced words.
    for line in reader:
        line = line.rstrip(""\n"")
        if count_straight_lines(line, font_description_dict) == count_curved_lines(line, font_description_dict):
            balanced_words.add(line)

    return balanced_words


if __name__ == ""__main__"":
    import doctest
    doctest.testmod()
",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( comment ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ( comment ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( comment ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),105,"{""filename"":""Izaak Van Evercooren/geometrische-letters.py"",""fullName"":""Izaak Van Evercooren"",""id"":""6017"",""status"":""runtime error"",""submissionID"":""6750625"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:13:42.000Z"",""labels"":""stat""}"
123,../exam-folder/Judit Dierickx/geometrische-letters.py,"def lees_lettertype(bestand):

    #bestand lezen
    with open(bestand, 'r') as invoer:
        letters = invoer.readlines()

    #dict maken en opbouwen
    lettertypes = {}
    for regel in letters:
        regel = regel.rstrip('\n')
        lettertypes[regel[0]] = (int(regel[-3]), int(regel[-1]))
    
    return lettertypes


def aantal_rechte_lijnen(woord, lettyp):

    """"""
    >>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
    21
    """"""
    lijnen = 0
    
    #elke letter afgaan en aantal rechte lijnen teruggeven
    for letter in woord:
        if letter.isalpha(): #niet-letters moeten genegeerd worden
            aantal = lettyp[letter][0]
            lijnen += aantal
    return lijnen


def aantal_kromme_lijnen(woord, lettyp):

    """"""
    >>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
    4
    """"""

    #bijna hetzelfde als aantal_rechte_lijnen
    krommen = 0
    
    #elke letter afgaan en aantal rechte lijnen teruggeven
    for letter in woord:
        if letter.isalpha(): #niet letters moeten genegeerd worden
            aantal = lettyp[letter][1]
            krommen += aantal
    return krommen


def enkel_rechte_lijnen(bestand, lettyp):

    """"""
    >>> enkel_rechte_lijnen('woordenboek.txt', lettertype)
    {'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
    """"""

    #bestand lezen
    with open(bestand, 'r') as invoer:
        woorden = invoer.readlines()

    #set maken en vullen met woorden zonder kromme lijnen
    rechten = set()
    for woord in woorden:
        woord = woord.rstrip('\n')
        if aantal_kromme_lijnen(woord, lettyp) == 0:
            rechten.add(woord)

    return rechten


def enkel_kromme_lijnen(bestand, lettyp):

    """"""
    >>> enkel_kromme_lijnen('woordenboek.txt', lettertype)
    {'COCCUS', 'COUSCOUS'}
    """"""

    #bestand lezen
    with open(bestand, 'r') as invoer:
        woorden = invoer.readlines()

    #set maken en vullen met woorden zonder rechte lijnen
    krommen = set()

    for woord in woorden:
        woord = woord.rstrip('\n')
        if aantal_rechte_lijnen(woord, lettyp) == 0:
            krommen.add(woord)

    return krommen


def gebalanceerde_lijnen(bestand, lettyp):

    """"""
    >>> gebalanceerde_lijnen('woordenboek.txt', lettertype)
    {'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}
    """"""

    #bestand lezen
    with open(bestand, 'r') as invoer:
        woorden = invoer.readlines()

    #set maken en vullen met woorden waarvan het aantal rechte lijnen = aantal kromme
    even = set()
    for woord in woorden:
        woord = woord.rstrip('\n')
        if aantal_rechte_lijnen(woord, lettyp) == aantal_kromme_lijnen(woord, lettyp):
            even.add(woord)

    return even
    
if __name__ == '__main__':
    import doctest
    doctest.testmod()",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( comment ) ( block ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( unary_operator ( integer ) ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( unary_operator ( integer ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),120,"{""filename"":""Judit Dierickx/geometrische-letters.py"",""fullName"":""Judit Dierickx"",""id"":""11749"",""status"":""correct"",""submissionID"":""6750521"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:10:59.000Z"",""labels"":""fyss""}"
124,../exam-folder/Emma Bekaert/geometrische-letters.py,"def lees_lettertype(locatie):
    """"""

    :param locatie: locatie str van tekstbestand met beschrijving lettertype
    :return: dict met key= karakter uit bestand, value= tuple met aantal rechte, aantal kromme lijnen
    """"""
    bestand = open(locatie)
    karakterlijst = bestand.read().split('\n')
    dict = {}
    for kar in karakterlijst[:-1]:
        lijstje = kar.split(' ')
        a = int(lijstje[1])
        b = int(lijstje[2])
        dict[lijstje[0]] = (a, b)
    return dict

def aantal_rechte_lijnen(woord, lettertype):
    """"""

    :param woord: string van letters
    :param lettertype: dictionary van lettertype
    :return: hoe veel rechte lijnen het woord bevat
    """"""
    aantal = 0
    for letter in woord:
        if letter in lettertype:
            aantal += list(lettertype[letter])[0]
    return aantal


def aantal_kromme_lijnen(woord, lettertype):
    """"""

    :param woord: string van letters
    :param lettertype: dictionary van lettertype
    :return: hoe veel kromme lijnen het woord bevat
    """"""
    aantal = 0
    for letter in woord:
        if letter in lettertype:
            aantal += list(lettertype[letter])[1]
    return aantal

def enkel_rechte_lijnen(locatie, lettertype):
    """"""

    :param locatie: locatie tekstbestand met reeks woorden
    :param lettertype: dictionary van lettertype
    :return: verzameling met woorden die enkel rechte lijnen hebben
    """"""
    bestand = open(locatie)
    woordenlst = bestand.read().splitlines()
    verzameling = set()
    for woord in woordenlst:
        woord.rstrip('\n')
        if aantal_kromme_lijnen(woord, lettertype) == 0:
            verzameling.add(woord)
    return verzameling

def enkel_kromme_lijnen(locatie, lettertype):
    """"""

    :param locatie: locatie tekstbestand met reeks woorden
    :param lettertype: dictionary van lettertype
    :return: verzameling met woorden die enkel kromme lijnen hebben
    """"""
    bestand = open(locatie)
    woordenlst = bestand.read().splitlines()
    verzameling = set()
    for woord in woordenlst:
        if aantal_rechte_lijnen(woord, lettertype) == 0:
            verzameling.add(woord)
    return verzameling

def gebalanceerde_lijnen(locatie, lettertype):
    """"""

    :param locatie: locatie tekstbestand met reeks woorden
    :param lettertype: dictionary van lettertype
    :return: verzameling met woorden die enkel kromme lijnen hebben
    """"""
    bestand = open(locatie)
    woordenlst = bestand.read().splitlines()
    verzameling = set()
    for woord in woordenlst:
        if aantal_rechte_lijnen(woord, lettertype) == aantal_kromme_lijnen(woord, lettertype):
            verzameling.add(woord)
    return verzameling",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( identifier ) ( identifier ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( identifier ) ) ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( identifier ) ) ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),104,"{""filename"":""Emma Bekaert/geometrische-letters.py"",""fullName"":""Emma Bekaert"",""id"":""11767"",""status"":""correct"",""submissionID"":""6749692"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:46:41.000Z"",""labels"":""geog""}"
125,../exam-folder/Oliver Mechthold/geometrische-letters.py,"def lees_lettertype(tekstbestand):
    """"""
    >>> lettertype['E']
    (4, 0)
    >>> lettertype['R']
    (2, 1)
    >>> lettertype['G']
    (1, 1)
    >>> lettertype['O']
    (0, 1)
    """"""
    #We openen het tekstbestand en lezen de eerste regel in, de '\n' (new lines) wordt via rstrip() verwijderd
    invoer = open(tekstbestand, 'r')
    inhoud = invoer.readline().rstrip()
    end = dict()
    
    #We blijven het bestand lezen zolang er tekst inzit.
    while inhoud:
        regel = inhoud.split(' ') #spaties verwijderen. 
        pos = int(regel[1]), int(regel[2]) #tuples maken van het rechte en kromme aantal lijnen (int gebruiken om van str naar getal te gaan)
        end[regel[0]] = tuple(pos) #letter toevoegen aan de dict en daaraan de tuple toekennen. 
        inhoud = invoer.readline().rstrip() #nieuwe regel inlezen. 
    invoer.close()
    return end

def aantal_rechte_lijnen(woord, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
    21
    """"""
    aantal = 0
    
    #Voor iedere letter in het woord bepalen we het aantal rechte lijnen, we houden er rekening mee dat 'letter' effectief een letter uit het alfabet moet zijn via isalpha()
    for letter in woord: 
        if letter.isalpha():
            m, n = lettertype[letter]
            aantal += int(m)
    return aantal

def aantal_kromme_lijnen(woord, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
    4
    """"""
    aantal = 0
    #Voor iedere letter in het woord bepalen we het aantal kromme lijnen, we houden er rekening mee dat 'letter' effectief een letter uit het alfabet moet zijn via isalpha()
    for letter in woord:
        if letter.isalpha():
            m, n = lettertype[letter]
            aantal += n
    return aantal

def enkel_rechte_lijnen(tekstbestand, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> enkel_rechte_lijnen('woordenboek.txt', lettertype)
    {'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
    """"""
    #We openen het nieuwe tekstbestand
    invoer = open(tekstbestand, 'r')
    inhoud = invoer.readline().rstrip()
    end = set()
    
    #We blijven inlezen zolang er tekst is in het bestand. Erna bepalen we het aantal rechte en kromme lijnen. Op basis daarvan (lijn 70) kunnen we dan toekennen of het woord in set mag. 
    while inhoud:
        regel = inhoud
        m = aantal_rechte_lijnen(regel, lettertype)
        n = aantal_kromme_lijnen(regel, lettertype)
        if m != 0 and n == 0:
            end.add(regel)
        inhoud = invoer.readline().rstrip() #volgende inlezen.
    invoer.close()
    return end

def enkel_kromme_lijnen(tekstbestand, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> enkel_kromme_lijnen('woordenboek.txt', lettertype)
    {'COCCUS', 'COUSCOUS'}
    """"""
    #idem als vorige functie enkel met ander statement.
    invoer = open(tekstbestand, 'r')
    inhoud = invoer.readline().rstrip()
    end = set()
    while inhoud:
        regel = inhoud
        m = aantal_rechte_lijnen(regel, lettertype)
        n = aantal_kromme_lijnen(regel, lettertype)
        if m == 0 and n != 0:
            end.add(regel)
        inhoud = invoer.readline().rstrip()
    invoer.close()
    return end

def gebalanceerde_lijnen(tekstbestand, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> gebalanceerde_lijnen('woordenboek.txt', lettertype)
    {'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}
    """"""
    #idem maar met ander statement.
    invoer = open(tekstbestand, 'r')
    inhoud = invoer.readline().rstrip()
    end = set()
    while inhoud:
        regel = inhoud
        m = aantal_rechte_lijnen(regel, lettertype)
        n = aantal_kromme_lijnen(regel, lettertype)
        if m == n:
            end.add(regel)
        inhoud = invoer.readline().rstrip()
    invoer.close()
    return end


if __name__ == '__main__':
    import doctest
    doctest.testmod()
",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( while_statement ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( expression_list ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ) ) ) ) ( comment ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( subscript ( identifier ) ( identifier ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( subscript ( identifier ) ( identifier ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( while_statement ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( identifier ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( boolean_operator ( comparison_operator ( identifier ) ( integer ) ) ( comparison_operator ( identifier ) ( integer ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ) ) ) ) ( comment ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( while_statement ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( identifier ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( boolean_operator ( comparison_operator ( identifier ) ( integer ) ) ( comparison_operator ( identifier ) ( integer ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( while_statement ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( identifier ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( identifier ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),162,"{""filename"":""Oliver Mechthold/geometrische-letters.py"",""fullName"":""Oliver Mechthold"",""id"":""11778"",""status"":""correct"",""submissionID"":""6750349"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:06:29.000Z"",""labels"":""keuz""}"
126,../exam-folder/Karen Leers/geometrische-letters.py,"def read_font(fontfile):
    # adding the elements from a txt file to a dictionary
    font_file = open(fontfile)
    fonts = {}

    for row in font_file:
        letter, straight, curved = row.split(' ')
        # removing the enter behind name
        curved = curved.replace('\n', '')
        fonts[letter] = (int(straight), int(curved))
    return fonts

def line_count(word, fonts):
    straight = 0
    curved = 0
    for i in word:
        if i not in fonts:
            continue
        straight += fonts[i][0]
        curved += fonts[i][1]
    return straight, curved

def count_straight_lines(word, fonts):
    straight_curved = line_count(word, fonts)
    return straight_curved[0]

def count_curved_lines(word, fonts):
    straight_curved = line_count(word, fonts)
    return straight_curved[1]

def straight_lines_only(file, fonts):
    wordfile = open(file)
    straight_words = set()

    for i in wordfile:
        i = i[:-1]      #removing '\n' at the end
        if count_curved_lines(i, fonts) == 0:
            straight_words.add(i)
    return straight_words


def curved_lines_only(file, fonts):
    wordfile = open(file)
    curved_words = set()

    for i in wordfile:
        i = i[:-1]      #removing '\n' at the end
        if count_straight_lines(i, fonts) == 0:
            curved_words.add(i)
    return curved_words

def balanced_lines(file, fonts):
    wordfile = open(file)
    balanced_words = set()

    for i in wordfile:
        i = i[:-1]      #removing '\n' at the end
        str, curv = line_count(i, fonts)
        if str == curv:
            balanced_words.add(i)
    return balanced_words
",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( tuple ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( continue_statement ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ( return_statement ( expression_list ( identifier ) ( identifier ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( return_statement ( subscript ( identifier ) ( integer ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( return_statement ( subscript ( identifier ) ( integer ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),94,"{""filename"":""Karen Leers/geometrische-letters.py"",""fullName"":""Karen Leers"",""id"":""11779"",""status"":""correct"",""submissionID"":""6749982"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:55:24.000Z"",""labels"":""biol""}"
127,../exam-folder/Robbe Vandenbroucke/geometrische-letters.py,"def lees_lettertype(locatie):
    
    #maakt een dictionary die de tuples associeert met een letter
    return {lijst[0]: (int(lijst[2]), int(lijst[4])) for lijst in open(locatie)}


def aantal_rechte_lijnen(woord, lettertype, n=0):
    
    #een derde parameter werd toegevoegd om de functie ook te kunnen gebruik voor de volgende functie
    #deze functie neemt de som van de waardes per letter
    return sum([lettertype[letter][n] for letter in woord if letter.isalpha()])


def aantal_kromme_lijnen(woord, lettertype, n=1):
    
    #deze functie gebruikt de vorige functie met een andere parameter n. Deze zorgt ervoor dat de aantal schuine
    #lijnen worden geteld ipv de rechte lijnen
    return aantal_rechte_lijnen(woord, lettertype, n)


def enkel_rechte_lijnen(locatie, lettertype, wat=aantal_kromme_lijnen):
    
    #geeft een set terug met de woorden die geen kromme lijnen bevatten. Opnieuw werd een derde parameter toegevoegd
    #om de functie ook voor de volgende functie te kunnen gebruiken
    return set(regel.rstrip(""\n"") for regel in open(locatie) if not wat(regel, lettertype))


def enkel_kromme_lijnen(locatie, lettertype, wat=aantal_rechte_lijnen):
    
    #de derde parameter wordt aangepast om zo dezelfde functie als de vorige te kunnen gebruiken
    return enkel_rechte_lijnen(locatie, lettertype, wat)


def gebalanceerde_lijnen(locatie, lettertype):
    
    #geeft een set terug met alle woorden die aan de voorwaarde voldoen dat er evenveel kromme als rechte lijnen zijn
    return set(regel.rstrip(""\n"") for regel in open(locatie)
               if aantal_rechte_lijnen(regel, lettertype) == aantal_kromme_lijnen(regel, lettertype))
",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( comment ) ( block ( return_statement ( dictionary_comprehension ( pair ( subscript ( identifier ) ( integer ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ( for_in_clause ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ( default_parameter ( identifier ) ( integer ) ) ) ( comment ) ( comment ) ( block ( return_statement ( call ( identifier ) ( argument_list ( list_comprehension ( subscript ( subscript ( identifier ) ( identifier ) ) ( identifier ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ( default_parameter ( identifier ) ( integer ) ) ) ( comment ) ( comment ) ( block ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ( default_parameter ( identifier ) ( identifier ) ) ) ( comment ) ( comment ) ( block ( return_statement ( call ( identifier ) ( generator_expression ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( for_in_clause ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ( if_clause ( not_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ( default_parameter ( identifier ) ( identifier ) ) ) ( comment ) ( block ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( return_statement ( call ( identifier ) ( generator_expression ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( for_in_clause ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ( if_clause ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ) ) ) ) ) ),58,"{""filename"":""Robbe Vandenbroucke/geometrische-letters.py"",""fullName"":""Robbe Vandenbroucke"",""id"":""11794"",""status"":""correct"",""submissionID"":""6749459"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:40:40.000Z"",""labels"":""keuz""}"
128,../exam-folder/Wout Houbart/geometrische-letters.py,"# https://dodona.ugent.be/nl/courses/359/series/4282/activities/1522917022/
def lees_lettertype(bestand):
    # dictionary definiren
    dict = {}
    
    # tekstbestand regel per regel overlopen; tuples definiren en toevoegen aan dictionary
    for regel in open(bestand):
        regel = regel.rstrip('\n') # de newlines worden verwijderd
        regel = regel.split(' ') # elementen isoleren
        letter = regel[0]
        recht = int(regel[1])
        krom = int(regel[2])
        dict[letter] = (recht, krom)
    return dict

def aantal_rechte_lijnen(woord, dictionary):
    aantal = int()
    
    # woord karakter per karakter overlopen en bijhorende values oproepen via dictionary
    for karakter in woord:
        if karakter.isalpha(): # value enkel ophalen als karakter een letter is
            aantal += dictionary[karakter][0]
    return aantal

def aantal_kromme_lijnen(woord, dictionary):
    aantal = int()

    # woord karakter per karakter overlopen en bijhorende values oproepen via dictionary
    for karakter in woord:
        if karakter.isalpha(): # value enkel ophalen als karakter een letter is
            aantal += dictionary[karakter][1]
    return aantal

def enkel_rechte_lijnen(tekst, dictionary):
    # verzameling definiren
    uitkomst = set()
    
    # tekstbestand regel per regel overlopen
    for regel in open(tekst):
        woord = regel.rstrip('\n') # de newlines worden verwijderd
        if aantal_kromme_lijnen(woord, dictionary) == 0: # er mogen geen kromme lijnen voorkomen
            uitkomst.add(woord)
    return uitkomst

def enkel_kromme_lijnen(tekst, dictionary):
    # verzameling definiren
    uitkomst = set()

    # tekstbestand regel per regel overlopen
    for regel in open(tekst):
        woord = regel.rstrip('\n') # de newlines worden verwijderd
        if aantal_rechte_lijnen(woord, dictionary) == 0: # er mogen geen rechte lijnen voorkomen
            uitkomst.add(woord)
    return uitkomst

def gebalanceerde_lijnen(tekst, dictionary):
    # verzameling definiren
    uitkomst = set()

    # tekstbestand regel per regel overlopen
    for regel in open(tekst):
        woord = regel.rstrip('\n') # de newlines worden verwijderd
        
        # gebalanceerd als en slechts als aantal_kromme_lijnen gelijk is aan aantal_rechte_lijnen
        if aantal_kromme_lijnen(woord, dictionary) == aantal_rechte_lijnen(woord, dictionary):
            uitkomst.add(woord)
    return uitkomst

if __name__ == '__main__':
    import doctest
    doctest.testmod()
",( module ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( comment ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( tuple ( identifier ) ( identifier ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),99,"{""filename"":""Wout Houbart/geometrische-letters.py"",""fullName"":""Wout Houbart"",""id"":""11796"",""status"":""correct"",""submissionID"":""6749190"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:35:04.000Z"",""labels"":""bcbt""}"
129,../exam-folder/Ayla Van Damme/geometrische-letters.py,"def lees_lettertype(locatie):

    uitvoer = dict()
    invoer = open(locatie)
    data = (invoer.readline()).strip('\n')  # lijn per lijn lezen zonder enters

    while data: #zolang er lijnen zijn
        data = data.split(' ')     # splitsen bij spatie
        uitvoer[data[0]] = (int(data[1]), int(data[-1]))
        data = (invoer.readline()).strip('\n')
    invoer.close()

    return uitvoer

def aantal_rechte_lijnen(woord, lettertype):

    som = 0     # totale som
    for letter in woord:    # voor elke letter
        if letter.upper() in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
            waarde = lettertype[letter] # waarde geven van de letter
            som += waarde[0]    # op index 0 staat het aantal rechte lijnen van de letter, deze wordt toegevoegd aan de som
    return som

def aantal_kromme_lijnen(woord, lettertype):
    # exact dezelfde code maar dan de waarde op index 1

    som = 0  # totale som
    for letter in woord:  # voor elke letter
        if letter.upper() in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
            waarde = lettertype[letter]  # waarde geven van de letter
            som += waarde[1]  # op index 1 staat het aantal rechte lijnen van de letter, deze wordt toegevoegd aan de som
    return som

def enkel_rechte_lijnen(reeks, lettertype):

    invoer = open(reeks, 'r')
    woord = (invoer.readline()).strip('\n')   # lijn per lijn lezen ofwel woord per woord

    uitvoer = set()   # alle woorden waarvoor de som van kromme == 0

    while woord:
        if aantal_kromme_lijnen(woord, lettertype) == 0:
            uitvoer.add(woord)
        woord = (invoer.readline()).strip('\n')   # lijn per lijn lezen ofwel woord per woord

    return uitvoer

def enkel_kromme_lijnen(reeks, lettertype):
    # exact dezelfde code maar dan met de functie 'enkel_rechte_lijnen' == 0

    invoer = open(reeks, 'r')
    woord = (invoer.readline()).strip('\n')  # lijn per lijn lezen ofwel woord per woord

    uitvoer = set()  # alle woorden waarvoor de som van rechten == 0

    while woord:
        if aantal_rechte_lijnen(woord, lettertype) == 0:
            uitvoer.add(woord)
        woord = (invoer.readline()).strip('\n')  # lijn per lijn lezen ofwel woord per woord

    return uitvoer

def gebalanceerde_lijnen(reeks, lettertype):

    invoer = open(reeks, 'r')
    woord = (invoer.readline()).strip('\n')  # lijn per lijn lezen ofwel woord per woord

    uitvoer = set()  # alle woorden waarvoor de som van rechten == som van krommen

    while woord:
        if aantal_rechte_lijnen(woord, lettertype) == aantal_kromme_lijnen(woord, lettertype):
            uitvoer.add(woord)
        woord = (invoer.readline()).strip('\n')  # lijn per lijn lezen ofwel woord per woord

    return uitvoer",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( parenthesized_expression ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( while_statement ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( unary_operator ( integer ) ) ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( parenthesized_expression ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( comparison_operator ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( string ) ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( identifier ) ) ) ) ( comment ) ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( comparison_operator ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( string ) ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( identifier ) ) ) ) ( comment ) ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( parenthesized_expression ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( while_statement ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( parenthesized_expression ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ) ) ( comment ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( parenthesized_expression ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( while_statement ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( parenthesized_expression ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ) ) ( comment ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( parenthesized_expression ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( while_statement ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( parenthesized_expression ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ) ) ( comment ) ( return_statement ( identifier ) ) ) ) ),130,"{""filename"":""Ayla Van Damme/geometrische-letters.py"",""fullName"":""Ayla Van Damme"",""id"":""11799"",""status"":""correct"",""submissionID"":""6747481"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T13:49:00.000Z"",""labels"":""bcbt""}"
130,../exam-folder/Warre Missiaen/geometrische-letters.py,"def lees_lettertype(bestand):
    with open(bestand,'r') as file:
        dic = dict()
        for lines in file.readlines():
            lines = lines.strip().split()
            dic[lines[0]] = int(lines[1]), int(lines[2])
    return dic
def aantal_rechte_lijnen(woord, dictionary):
    woord = ''.join([letters for letters in woord if letters.isalpha()])
    return sum([dictionary[letter][0] for letter in woord])
def aantal_kromme_lijnen(woord, dictionary):
    woord = ''.join([letters for letters in woord if letters.isalpha()])
    return sum([dictionary[letter][1] for letter in woord])
    
#Om herhaling te vermijden schrijf ik alles in een algemene code. De individuele functies maken dan gebruik van deze code
    
def algemeen(bestand, dictionary):
    bijhouden1, bijhouden2, bijhouden3 = set(), set(), set()
    with open(bestand, 'r') as file:
        for lines in file.readlines():
            lines = lines.strip()
            if not aantal_kromme_lijnen(lines, dictionary):
                bijhouden1.add(lines)
            if not aantal_rechte_lijnen(lines, dictionary):
                bijhouden2.add(lines)
            if aantal_rechte_lijnen(lines, dictionary) == aantal_kromme_lijnen(lines, dictionary):
                bijhouden3.add(lines)
    return bijhouden1, bijhouden2, bijhouden3
    
def enkel_rechte_lijnen(bestand, dictionary):
    return algemeen(bestand, dictionary)[0]
    
def enkel_kromme_lijnen(bestand, dictionary):
    return algemeen(bestand, dictionary)[1]
def gebalanceerde_lijnen(bestand, dictionary):
    return algemeen(bestand, dictionary)[2]
    ",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( expression_list ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( string ) ( identifier ) ) ( argument_list ( list_comprehension ( identifier ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ) ) ( return_statement ( call ( identifier ) ( argument_list ( list_comprehension ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ( for_in_clause ( identifier ) ( identifier ) ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( string ) ( identifier ) ) ( argument_list ( list_comprehension ( identifier ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ) ) ( return_statement ( call ( identifier ) ( argument_list ( list_comprehension ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ( for_in_clause ( identifier ) ( identifier ) ) ) ) ) ) ) ) ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( expression_list ( call ( identifier ) ( argument_list ) ) ( call ( identifier ) ( argument_list ) ) ( call ( identifier ) ( argument_list ) ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( if_statement ( not_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( if_statement ( not_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( expression_list ( identifier ) ( identifier ) ( identifier ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ),96,"{""filename"":""Warre Missiaen/geometrische-letters.py"",""fullName"":""Warre Missiaen"",""id"":""11807"",""status"":""correct"",""submissionID"":""6749612"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:44:53.000Z"",""labels"":""fyss""}"
131,../exam-folder/Jana De Coster/geometrische-letters.py,"def read_font(file):
    #put all the lines of the file in a list
    f = open(file, 'r')
    lines = f.readlines()
    
    # create a new dictionary
    dic = dict()
    
    #remove the \n from all the lines
    for line in lines:
        line = line.strip()
        
        #create the dictionary keys and add the valuess to the right keys
        dic[line[0]] = (int(line[2]), int(line[4]))
    return dic

def count_straight_lines(w, f):
    #create an empty count
    y = 0
    
    #replace all the accents (are notr needed)
    w = w.replace(""'"", """")
    

    for i in range(len(w)):
        #get the values for each letter of the word        
        x = f[w[i]]
        
        #make a list out of these elements so we can get the correct values
        x = list(f[w[i]])
        
        #add the amount of straight lines to the count
        y += x[0]
    return y

def count_curved_lines(w, f):
    #create an empty value
    y = 0
    
    #replace all the accents (are notr needed)
    w = w.replace(""'"", """")
    

    for i in range(len(w)):
        #get the values for each letter of the word        
        x = f[w[i]]
        
        #make a list out of these elements so we can get the correct values
        x = list(f[w[i]])
        
        #add the amount of curved lines to the count
        y += x[1]
    return y

def straight_lines_only(file1, dic):
    #put all the lines of the file in a list
    f = open(file1, 'r')
    lines = f.readlines()
    
    #create an empty set
    x = set()
    for line in lines:
        #remove the \n form each line and replace accents (for now)
        line = line.strip()
        line2 = line.replace(""'"", """")
        
        #get the amount of curved lines
        r = count_curved_lines(line2, dic)
        
        #if the amount of curved lines is 0 then add the word to the set
        if r == 0:
            x.add(line)
    return x

def curved_lines_only(file1, dic):
    #put all the lines of the file in a list
    f = open(file1, 'r')
    lines = f.readlines()
    
    #create an empty set
    x = set()
    for line in lines:
        #remove the \n form each line and replace accents (for now)
        line = line.strip()
        line2 = line.replace(""'"", """")
        
        #get the amount of curved lines
        r = count_straight_lines(line2, dic)
        
        #if the amount of straight lines is 0 then add the word to the set
        if r == 0:
            x.add(line)
    return x

def balanced_lines(file1, dic):
    #put all the lines of the file in a list
    f = open(file1, 'r')
    lines = f.readlines()
    
    #create an empty set
    x = set()
    for line in lines:
        #remove the \n form each line and replace accents (for now)
        line = line.strip()
        line2 = line.replace(""'"", """")
        
        #get the amount of curved lines and straight lines
        r = count_straight_lines(line2, dic)
        s = count_curved_lines(line2, dic)
        
        #if the amount of curved lines is tghe same as the amount of straight lines then add the word to the set
        if r == s:
            x.add(line)
    return x

def line_count(word, dic):
    #create two empty counts
    y = 0
    x = 0
    
    for i in range(len(word)):
        #create a list out of the values of the key
        r = list(dic[word[i]])
        
        #add the values to the counts
        y += r[1]
        x += r[0]
    return x, y

if __name__ == '__main__':
    import doctest
    doctest.testmod()",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( comment ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( subscript ( identifier ) ( identifier ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( subscript ( identifier ) ( identifier ) ) ) ) ) ) ) ( comment ) ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( subscript ( identifier ) ( identifier ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( subscript ( identifier ) ( identifier ) ) ) ) ) ) ) ( comment ) ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( subscript ( identifier ) ( identifier ) ) ) ) ) ) ) ( comment ) ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ) ) ( return_statement ( expression_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),180,"{""filename"":""Jana De Coster/geometrische-letters.py"",""fullName"":""Jana De Coster"",""id"":""9300"",""status"":""correct"",""submissionID"":""6749939"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:54:01.000Z"",""labels"":""keuz""}"
132,../exam-folder/Jan De Mey/geometrische-letters.py,"def lees_lettertype(lettertype_bestand):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> lettertype['E']
    (4, 0)
    >>> lettertype['R']
    (2, 1)
    >>> lettertype['G']
    (1, 1)
    >>> lettertype['O']
    (0, 1)
    """"""
    # open bestand
    invoer = open(lettertype_bestand, 'r')

    # iterate door lijnen, maak dictionary
    dict = {}
    for line in invoer:
        stripped = line.rstrip('\n')
        element = stripped.split(' ')
        dict[element[0]] = (int(element[1]), int(element[2])) # dict moet ints bevatten

    return dict

def aantal_rechte_lijnen(woord, lettertype):
    """"""
    >>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
    21
    """"""
    dict = lettertype

    # iterate door alle letters, zoek overeenkomstige waarde op in dict.
    aantal_lijnen = 0
    for letter in woord:
        if letter in dict:
            aantal_lijnen += dict[letter][0]

    return aantal_lijnen

def aantal_kromme_lijnen(woord, lettertype):
    """"""
    >>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
    4
    """"""

    dict = lettertype

    # iterate door alle letters, zoek overeenkomstige waarde op in dict.
    aantal_lijnen = 0
    for letter in woord:
        if letter in dict:
            aantal_lijnen += dict[letter][1]

    return aantal_lijnen

def enkel_rechte_lijnen(input_bestand, lettertype):
    """"""
    >>> enkel_rechte_lijnen('woordenboek.txt', lettertype)
    {'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
    """"""
    # open bestand
    invoer = open(input_bestand, 'r')

    # initialiseer list, iterate door lijnen en voeg elk woord toe aan list
    input_list = []
    for line in invoer:
        stripped = line.rstrip('\n')
        input_list.append(stripped)

    # initialiseer list, geef elk element van input_list door aan functie aantal_kromme_lijnen,
    # en voeg alle elementen zonder kromme lijnen toe aan output_list
    output_list = []
    for element in input_list:
        kromme_lijnen = aantal_kromme_lijnen(element, lettertype)
        if kromme_lijnen == 0:
            output_list.append(element)

    return set(output_list)


def enkel_kromme_lijnen(input_bestand, lettertype):
    """"""
    >>> enkel_kromme_lijnen('woordenboek.txt', lettertype)
    {'COCCUS', 'COUSCOUS'}
    """"""
    # open bestand
    invoer = open(input_bestand, 'r')

    # initialiseer list, iterate door lijnen en voeg elk woord toe aan list
    input_list = []
    for line in invoer:
        stripped = line.rstrip('\n')
        input_list.append(stripped)

    # initialiseer list, geef elk element van input_list door aan functie aantal_rechte_lijnen,
    # en voeg alle elementen zonder rechte lijnen toe aan output_list
    output_list = []
    for element in input_list:
        rechte_lijnen = aantal_rechte_lijnen(element, lettertype)
        if rechte_lijnen == 0:
            output_list.append(element)

    return set(output_list)


def gebalanceerde_lijnen(input_bestand, lettertype):
    """"""
    >>> gebalanceerde_lijnen('woordenboek.txt', lettertype)
    {'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}
    """"""
    # open bestand
    invoer = open(input_bestand, 'r')

    # initialiseer list, iterate door lijnen en voeg elk woord toe aan list
    input_list = []
    for line in invoer:
        stripped = line.rstrip('\n')
        input_list.append(stripped)

    # initialiseer list, geef elk element van input_list door aan functie aantal_rechte_lijnen en aantal_kromme_lijnen,
    # en voeg alle elementen met evenveel rechte als kromme lijnen toe aan output_list
    output_list = []
    for element in input_list:
        rechte_lijnen = aantal_rechte_lijnen(element, lettertype)
        kromme_lijnen = aantal_kromme_lijnen(element, lettertype)
        if rechte_lijnen == kromme_lijnen:
            output_list.append(element)

    return set(output_list)


if __name__ == '__main__':
    import doctest
    doctest.testmod()",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ( comment ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( identifier ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( identifier ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( list ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( comment ) ( comment ) ( expression_statement ( assignment ( identifier ) ( list ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( list ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( comment ) ( comment ) ( expression_statement ( assignment ( identifier ) ( list ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( list ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( comment ) ( comment ) ( expression_statement ( assignment ( identifier ) ( list ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),134,"{""filename"":""Jan De Mey/geometrische-letters.py"",""fullName"":""Jan De Mey"",""id"":""11020"",""status"":""correct"",""submissionID"":""6749790"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:50:05.000Z"",""labels"":""keuz""}"
133,../exam-folder/Aag Bogaert/geometrische-letters.py,"def lees_lettertype(locatie):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> lettertype['E']
    (4, 0)
    >>> lettertype['R']
    (2, 1)
    >>> lettertype['G']
    (1, 1)
    >>> lettertype['O']
    (0, 1)
    """"""
    bestand = open(locatie, 'r')
    lettertype_dictio = {}

    for regel in bestand:
        regel = regel.rstrip('\n')
        karakter, rechte, kromme = regel.split(' ')
        lettertype_dictio[karakter] = int(rechte), int(kromme)

    return lettertype_dictio

def aantal_rechte_lijnen(woord, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
    21
    """"""
    # via de dictionary in de vorige functie gemaakt het aantal rechte lijnen optellen dat in het gegeven woord wordt gebruikt
    som_rechte = 0

    for letter in woord:
        if letter in lettertype:
            som_rechte += lettertype[letter][0]

    return som_rechte

def aantal_kromme_lijnen(woord, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
    4
    """"""
    som_kromme = 0

    for letter in woord:
        if letter in lettertype:
            som_kromme += lettertype[letter][1]

    return som_kromme

def enkel_rechte_lijnen(locatie_woorden, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> enkel_rechte_lijnen('woordenboek.txt', lettertype)
    {'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
    """"""
    woorden = open(locatie_woorden, 'r')

    verzameling_rechte = set()

    for woord in woorden:
        woord = woord.rstrip('\n')
        if aantal_kromme_lijnen(woord, lettertype) == 0:
            verzameling_rechte.add(woord)

    return verzameling_rechte

def enkel_kromme_lijnen(locatie_woorden, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> enkel_kromme_lijnen('woordenboek.txt', lettertype)
    {'COCCUS', 'COUSCOUS'}
    """"""
    woorden = open(locatie_woorden, 'r')

    verzameling_kromme = set()

    for woord in woorden:
        woord = woord.rstrip('\n')
        if aantal_rechte_lijnen(woord, lettertype) == 0:
            verzameling_kromme.add(woord)

    return verzameling_kromme

def gebalanceerde_lijnen(locatie_woorden, lettertype):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> gebalanceerde_lijnen('woordenboek.txt', lettertype)
    {'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}
    """"""
    woorden = open(locatie_woorden, 'r')

    verzameling_balans = set()

    for woord in woorden:
        woord = woord.rstrip('\n')
        if aantal_rechte_lijnen(woord, lettertype) == aantal_kromme_lijnen(woord, lettertype):
            verzameling_balans.add(woord)

    return verzameling_balans

if __name__ == '__main__':
    import doctest
    doctest.testmod()",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( expression_list ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),99,"{""filename"":""Aag Bogaert/geometrische-letters.py"",""fullName"":""Aag Bogaert"",""id"":""11922"",""status"":""correct"",""submissionID"":""6749996"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:56:15.000Z"",""labels"":""geog""}"
134,../exam-folder/Antoine Anneessens/geometrische-letters.py,"def lees_lettertype(bestand):
    lettertype = {}
    for regel in open(bestand, 'r'):
        letter, recht, krom = regel.strip().split(' ')
        lettertype[letter] = int(recht), int(krom)
    return lettertype
def aantal_rechte_lijnen(woord, bestand):
    resultaat = 0
    bestand = str(bestand)
    bestand += '.txt'
    lettertype = {}
    for regel in open(bestand, 'r'):
        letter, recht, krom = regel.strip().split(' ')
        lettertype[letter] = int(recht)
    for letter in woord:
        lezen_per_lijn = lettertype.readlines()
        if lezen_per_lijn.startswith(letter):
            resultaat += recht
    return resultaat

def aantal_kromme_lijnen(woord, bestand):
    resultaat = 0
    bestand = str(bestand)
    bestand += '.txt'
    lettertype = {}
    for regel in open(bestand, 'r'):
        letter, recht, krom = regel.strip().split(' ')
        lettertype[letter] = int(recht)
    for letter in woord:
        lezen_per_lijn = lettertype.readlines()
        if lezen_per_lijn.startswith(letter):
            resultaat += krom
    return resultaat",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( expression_list ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( string ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( string ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),81,"{""filename"":""Antoine Anneessens/geometrische-letters.py"",""fullName"":""Antoine Anneessens"",""id"":""11934"",""status"":""runtime error"",""submissionID"":""6750606"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:13:08.000Z"",""labels"":""geog""}"
135,../exam-folder/Gil Glorieus/geometrische-letters.py,"""""""
>>> lettertype = lees_lettertype('lettertype.txt')
>>> lettertype['E']
(4, 0)
>>> lettertype['R']
(2, 1)
>>> lettertype['G']
(1, 1)
>>> lettertype['O']
(0, 1)

>>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
21
>>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
4

>>> enkel_rechte_lijnen('woordenboek.txt', lettertype)
{'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
>>> enkel_kromme_lijnen('woordenboek.txt', lettertype)
{'COCCUS', 'COUSCOUS'}
>>> gebalanceerde_lijnen('woordenboek.txt', lettertype)
{'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}
""""""


def lees_lettertype(locatie):
    bestand = open(locatie, 'r')
    regel = bestand.readline()
    wb = dict()
    while regel:
        
        # splitsen in 3 delen bij de spaties: letter, aantal rechte lijnen en aantal kromme lijnen
        gesplitst = regel.rstrip('\n').split(' ')
        
        # in de dictionary is de letter de sleutel
        # de waarde is een tuple met eerst het aantal rechte lijnen en dan het aantal kromme lijnen
        wb[gesplitst[0]] = (int(gesplitst[1]), int(gesplitst[2]))
        
        regel = bestand.readline()
        
    return wb


def aantal_rechte_lijnen(woord, wb):
    aantal = 0
    for karakter in woord:
        
        # enkel in de dictionary zoeken als het karakter een letter is
        if karakter.isalpha():
            
            # zoeken in de dictionary met de letter als sleutel
            # aantal rechte lijnen is het eerste element van de tuple bij de waarde van deze sleutel
            aantal += wb[karakter][0]
            
    return aantal


def aantal_kromme_lijnen(woord, wb):
    aantal = 0
    for karakter in woord:

        # enkel in de dictionary zoeken als het karakter een letter is
        if karakter.isalpha():
            
            # zoeken in de dictionary met de letter als sleutel
            # aantal kromme lijnen is het tweede element van de tuple bij de waarde van deze sleutel
            aantal += wb[karakter][1]
            
    return aantal


def enkel_rechte_lijnen(locatie, wb):
    bestand = open(locatie, 'r')
    regel = bestand.readline()
    uitvoer = set()
    while regel:
        woord = regel.rstrip('\n')
        
        # woord toevoegen aan de set als het geen kromme lijnen heeft
        if aantal_kromme_lijnen(woord, wb) == 0:
            uitvoer.add(woord)
            
        regel = bestand.readline()
        
    return uitvoer


def enkel_kromme_lijnen(locatie, wb):
    bestand = open(locatie, 'r')
    regel = bestand.readline()
    uitvoer = set()
    while regel:
        woord = regel.rstrip('\n')

        # woord toevoegen aan de set als het geen rechte lijnen heeft
        if aantal_rechte_lijnen(woord, wb) == 0:
            uitvoer.add(woord)
            
        regel = bestand.readline()
        
    return uitvoer


def gebalanceerde_lijnen(locatie, wb):
    bestand = open(locatie, 'r')
    regel = bestand.readline()
    uitvoer = set()
    while regel:
        woord = regel.rstrip('\n')

        # woord toevoegen aan de set als het evenveel rechte als kromme lijnen heeft
        if aantal_rechte_lijnen(woord, wb) == aantal_kromme_lijnen(woord, wb):
            uitvoer.add(woord)
            
        regel = bestand.readline()
        
    return uitvoer


if __name__ == '__main__':
    import doctest
    doctest.testmod()
",( module ( expression_statement ( string ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( while_statement ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( comment ) ( comment ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( comment ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( comment ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( while_statement ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( while_statement ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( while_statement ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),119,"{""filename"":""Gil Glorieus/geometrische-letters.py"",""fullName"":""Gil Glorieus"",""id"":""11948"",""status"":""correct"",""submissionID"":""6748793"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:25:18.000Z"",""labels"":""geog""}"
136,../exam-folder/Cdric De Smet/geometrische-letters.py,"def lees_lettertype(bestand): #Elk karakter moet in een dictionary, met als value een tuple met zijn lijnaantallen
    dictionary = dict()
    bestand = open(bestand, 'r')
    bestand = bestand.readlines()
    file = list() #We maken een weergave met splitsing op basis van spatie (en ook verwijdering van witregels)
    for regel in bestand:
        regel = regel.rstrip('\n')
        regel = regel.split(' ')
        file.append(regel)
    for regel in file:
        lijngetallen = (int(regel[1]), int(regel[2]))
        dictionary[regel[0]] = lijngetallen
    return dictionary

def aantal_rechte_lijnen(woord, letterbeschrijving): #Nagaan hoeveel rechte lijnen er in het woord zijn met behulp van een dictionary zoals er een werd opgesteld in functie 1
    aantal = 0
    for letter in woord:
        if letter.isalpha(): #Enkel voor letters nagaan
            aantal += letterbeschrijving[letter][0] #Eerst dus de tuple met aantal lijnen verwerven, dan hiervan het eerste getal
    return aantal

def aantal_kromme_lijnen(woord, letterbeschrijving): #Deze doet hetzelfde als de voorgaande functie, maar voor kromme lijnen
    aantal = 0
    for letter in woord:
        if letter.isalpha():  # Enkel voor letters nagaan
            aantal += letterbeschrijving[letter][1]  # Eerst dus de tuple met aantal lijnen verwerven, dan hiervan het tweede getal
    return aantal

def zonderwitregelsopenen(bestand): #Extra functie apart omdat deze gebruikt wordt in volgende drie functies
    bestand = open(bestand, 'r')
    bestand = bestand.readlines()
    file = list()  # We maken een weergave met verwijdering van witregels
    for regel in bestand:
        regel = regel.rstrip('\n')
        file.append(regel)
    return file

def enkel_rechte_lijnen(bestand, letterbeschrijving): #We maken een set met getallen uit het bestand welke enkel met rechte lijnen worden geschreven
    enkelrecht = set()
    file = zonderwitregelsopenen(bestand)
    for woord in file:
        if aantal_kromme_lijnen(woord, letterbeschrijving) == 0: #Dus enkel rechten
            enkelrecht.add(woord)
    return enkelrecht

def enkel_kromme_lijnen(bestand, letterbeschrijving): #We maken een set met getallen uit het bestand welke enkel met kromme lijnen worden geschreven (omgekeerde voorgaande)
    enkelkrom = set()
    file = zonderwitregelsopenen(bestand)
    for woord in file:
        if aantal_rechte_lijnen(woord, letterbeschrijving) == 0: #Dus enkel krommen
            enkelkrom.add(woord)
    return enkelkrom

def gebalanceerde_lijnen(bestand, letterbeschrijving): #We maken een set aan woorden met evenveel kromme als rechte lijnen (principe analoog aan twee voorgaande functies)
    evenveel = set()
    file = zonderwitregelsopenen(bestand)
    for woord in file:
        if aantal_rechte_lijnen(woord, letterbeschrijving) == aantal_kromme_lijnen(woord, letterbeschrijving):  # Dus even veel van beiden
            evenveel.add(woord)
    return evenveel",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( identifier ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),121,"{""filename"":""Cdric De Smet/geometrische-letters.py"",""fullName"":""Cdric De Smet"",""id"":""11928"",""status"":""correct"",""submissionID"":""6749392"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:39:05.000Z"",""labels"":""bcbt""}"
137,../exam-folder/Ellen Blomme/geometrische-letters.py,"""""""
>>> font = read_font('font.txt')
>>> font['E']
(4, 0)
>>> font['R']
(2, 1)
>>> font['G']
(1, 1)
>>> font['O']
(0, 1)

>>> line_count('ERGONOMICS', font)
(17, 6)
>>> count_straight_lines('ERGONOMICS', font)
17
>>> count_curved_lines('ERGONOMICS', font)
6

>>> straight_lines_only('dictionary.txt', font)
{'ALKALINE', 'MILLENNIAL', 'INFINITELY'}
>>> curved_lines_only('dictionary.txt', font)
{'COCCUS', 'COUSCOUS'}
>>> balanced_lines('dictionary.txt', font)
{'AUGUSTUS', 'CROSSROAD', 'SUDOKU', 'COLUMBUS', 'PROCESSORS'}
""""""


def read_font(textfile):
    dictionary = {}
    # we first map all the characters in a dictionary
    for line in open(textfile):
        # therefor we need to split each line in character; straight and curved
        char, x, y = line.rstrip().split()
        # in the dictionary we only want integers
        dictionary[char] = (int(x), int(y))
    return dictionary


def line_count(word, font):
    total = [0, 0]
    # we need the lines for each character
    for char in word:
        if char.isalpha():
            # only letters of the alphabet are in the dictionary
            for index, number in enumerate(font[char]):
                # we will get (straight, curved) we need to add this respectively to each position in the list
                total[index] += number
    return tuple(total)


def count_straight_lines(word, font):
    return line_count(word, font)[0]


def count_curved_lines(word, font):
    return line_count(word, font)[1]


def straight_lines_only(words, font):
    result = set()
    with open(words) as dictionary:
        # we need to define for each word if the curved lines are 0
        for word in dictionary:
            word = word.rstrip()
            if count_curved_lines(word, font) == 0:
                result.add(word)
    return result


def curved_lines_only(words, font):
    result = set()
    with open(words) as dictionary:
        # we need to define for each word if the straight lines are 0
        for word in dictionary:
            word = word.rstrip()
            if count_straight_lines(word, font) == 0:
                result.add(word)
    return result


def balanced_lines(words, font):
    result = set()
    with open(words) as dictionary:
        # we need to define for each word if the lines are balanced
        for word in dictionary:
            word = word.rstrip()
            if count_straight_lines(word, font) == count_curved_lines(word, font):
                result.add(word)
    return result


if __name__ == '__main__':
    import doctest

    doctest.testmod()
",( module ( expression_statement ( string ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( comment ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ( comment ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ) ) ) ) ( comment ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( tuple ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( list ( integer ) ( integer ) ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( comment ) ( block ( for_statement ( pattern_list ( identifier ) ( identifier ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( identifier ) ) ) ) ( comment ) ( block ( expression_statement ( augmented_assignment ( subscript ( identifier ) ( identifier ) ) ( identifier ) ) ) ) ) ) ) ) ) ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( comment ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( comment ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( comment ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),92,"{""filename"":""Ellen Blomme/geometrische-letters.py"",""fullName"":""Ellen Blomme"",""id"":""11961"",""status"":""correct"",""submissionID"":""6750554"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:11:50.000Z"",""labels"":""biol""}"
138,../exam-folder/Paulien D'Hondt/geometrische-letters.py,"def lees_lettertype(tekst):
    file = open(tekst, 'r')
    dict = {}
    for regel in file.readlines():
        regel = regel.strip('\n')
        karakter, recht, krom = regel.split('\t')[0], regel.split('\t')[1], regel.split('\t')[2]
        dict[karakter] = recht, krom
    return dict

def aantal_rechte_lijnen(woord, lettertype):
    som = 0
    index = 0
    while index < len(woord) - 1:
        for index, letter in enumerate(woord):
            letter = lettertype[letter]
            aantal = letter[0]
            som += aantal
            index += 1
    return som

def aantal_kromme_lijnen(woord, lettertype):
    som = 0
    index = 0
    while index < len(woord) - 1:
        for index, letter in enumerate(woord):
            letter = lettertype[letter]
            aantal = letter[1]
            som += aantal
            index += 1
    return som

def enkel_rechte_lijnen(tekst, lettertype):
    woorden = set()
    file = open(tekst, 'r')
    for regel in file.readlines():
        for letter in regel:
            letter = lettertype[letter]
            if letter[0] == 0:
                regel += 1
            else:
                letter += 1
            woorden.add(regel)
    return woorden

def enkel_kromme_lijnen(tekst, lettertype):
    woorden = set()
    file = open(tekst, 'r')
    for regel in file.readlines():
        for letter in regel:
            letter = lettertype[letter]
            if letter[1] == 0:
                regel += 1
            else:
                letter += 1
            woorden.add(regel)
    return woorden

def gebalanceerde_lijnen(tekst, lettertype):
    woorden = set()
    file = open(tekst, 'r')
    for regel in file.readlines():
        for letter in regel:
            letter = lettertype[letter]
            if aantal_kromme_lijnen(woord=regel) == aantal_rechte_lijnen(woord=regel):
                woorden.add(regel)
    return woorden
",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( expression_list ( subscript ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( integer ) ) ( subscript ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( integer ) ) ( subscript ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( integer ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( expression_list ( identifier ) ( identifier ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( while_statement ( comparison_operator ( identifier ) ( binary_operator ( call ( identifier ) ( argument_list ( identifier ) ) ) ( integer ) ) ) ( block ( for_statement ( pattern_list ( identifier ) ( identifier ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( identifier ) ) ) ) ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( integer ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( while_statement ( comparison_operator ( identifier ) ( binary_operator ( call ( identifier ) ( argument_list ( identifier ) ) ) ( integer ) ) ) ( block ( for_statement ( pattern_list ( identifier ) ( identifier ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( identifier ) ) ) ) ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( integer ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( identifier ) ) ) ) ( if_statement ( comparison_operator ( subscript ( identifier ) ( integer ) ) ( integer ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( integer ) ) ) ) ( else_clause ( block ( expression_statement ( augmented_assignment ( identifier ) ( integer ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( identifier ) ) ) ) ( if_statement ( comparison_operator ( subscript ( identifier ) ( integer ) ) ( integer ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( integer ) ) ) ) ( else_clause ( block ( expression_statement ( augmented_assignment ( identifier ) ( integer ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( identifier ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( keyword_argument ( identifier ) ( identifier ) ) ) ) ( call ( identifier ) ( argument_list ( keyword_argument ( identifier ) ( identifier ) ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),135,"{""filename"":""Paulien D'Hondt/geometrische-letters.py"",""fullName"":""Paulien D'Hondt"",""id"":""11974"",""status"":""runtime error"",""submissionID"":""6750593"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:12:43.000Z"",""labels"":""geog""}"
139,../exam-folder/Anton Leagre/geometrische-letters.py,"def lees_lettertype(txt: str) -> dict:
    """"""
    :param txt: locatie van een tekstbestand dat een lettertype voorstelt (str)
    :return: een dictionary die voor elk karakter in het bestand het aantal rechte en kromme lijnen weergeeft in een tuple (R,K) (dict)
    """"""
    out = {}
    with open(txt) as file:
        for line in file:
            splits = line.split()
            out[splits[0]] = (int(splits[1]), int(splits[2])) #Format is
    return out


def aantal_rechte_lijnen(word: str, lettertype: dict) -> int:
    """"""
    :param word: een woord  (str)
    :param lettertype: een lettertype als gegeven in lees_lettertype (dict)
    :return: aantal rechte lijnen in het woord (int)
    """"""
    return sum(lettertype[c][0] for c in word if c in lettertype)


def aantal_kromme_lijnen(word: str, lettertype: dict) -> int:
    """"""
    :param word: een woord  (str)
    :param lettertype: een lettertype als gegeven in lees_lettertype (dict)
    :return: aantal kromme lijnen in het woord (int)
    """"""
    return sum(lettertype[c][1] for c in word if c in lettertype)


def enkel_rechte_lijnen(txt: str, lettertype: dict) -> set:
    """"""
    :param txt: locatie van een tekstbestand met woorden (str)
    :param lettertype: een lettertype als gegeven in lees_lettertype (dict)
    :return: een verzameling met de woorden in het bestand die enkel rechte lijnen bevatten (set)
    """"""
    with open(txt) as file:
        return {word.rstrip() for word in file if aantal_kromme_lijnen(word, lettertype) == 0} #rstrip verwijdert de \n


def enkel_kromme_lijnen(txt, lettertype):
    """"""
    :param txt: locatie van een tekstbestand met woorden (str)
    :param lettertype: een lettertype als gegeven in lees_lettertype (dict)
    :return: een verzameling met de woorden in het bestand die enkel kromme lijnen bevatten (set)
    """"""
    with open(txt) as file:
        return {word.rstrip() for word in file if aantal_rechte_lijnen(word, lettertype) == 0}


def gebalanceerde_lijnen(txt, lettertype):
    """"""
    :param txt: locatie van een tekstbestand met woorden (str)
    :param lettertype: een lettertype als gegeven in lees_lettertype (dict)
    :return: een verzameling met de woorden in het bestand die evenveel kromme als rechte lijnen bevatten (set)
    """"""
    with open(txt) as file:
        return {word.rstrip() for word in file if
                aantal_rechte_lijnen(word, lettertype) == aantal_kromme_lijnen(word, lettertype)}",( module ( function_definition ( identifier ) ( parameters ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ) ( type ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ) ( type ( identifier ) ) ( block ( expression_statement ( string ) ) ( return_statement ( call ( identifier ) ( generator_expression ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( comparison_operator ( identifier ) ( identifier ) ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ) ( type ( identifier ) ) ( block ( expression_statement ( string ) ) ( return_statement ( call ( identifier ) ( generator_expression ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( comparison_operator ( identifier ) ( identifier ) ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ) ( type ( identifier ) ) ( block ( expression_statement ( string ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( block ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ) ) ) ) ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( block ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( block ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ) ) ) ) ) ) ),75,"{""filename"":""Anton Leagre/geometrische-letters.py"",""fullName"":""Anton Leagre"",""id"":""12010"",""status"":""correct"",""submissionID"":""6748445"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:17:48.000Z"",""labels"":""fyss""}"
140,../exam-folder/Jana Goes/geometrische-letters.py,"def lees_lettertype(tekstbestand):

    # lege dictionary starten
    dictionary = {}

    # regel per regel inlezen en aan dictionary toevoegen
    for regel in open(tekstbestand, 'r'):
        lijst = regel.rstrip('\n').split(' ')
        dictionary[lijst[0]] = (int(lijst[1]),int(lijst[2]))

    return dictionary

def aantal_rechte_lijnen(woord, dictionary):

    # som intialiseren
    som = 0

    # voor elke letter de waarde bij som optellen
    for letter in woord:
        if letter.isalpha():
            som += dictionary[letter][0]

    return som

def aantal_kromme_lijnen(woord, dictionary):

    # som intialiseren
    som = 0

    # voor elke letter de waarde bij som optellen
    for letter in woord:
        if letter.isalpha():
            som += dictionary[letter][1]

    return som

def enkel_rechte_lijnen(tekstbestand, dictionary):

    # lege verzameling initialiseren
    verzameling = set()

    # voor elk woord aantal kromme en rechte lijnen bepalen
    for woord in open(tekstbestand, 'r'):
        woord = woord.rstrip('\n')
        kromme_lijnen = aantal_kromme_lijnen(woord, dictionary)

        # enkel woorden toevoegen met 0 kromme lijnen
        if kromme_lijnen == 0:
            verzameling.add(woord)

    return verzameling

def enkel_kromme_lijnen(tekstbestand, dictionary):

    # lege verzameling initialiseren
    verzameling = set()

    # voor elk woord aantal kromme en rechte lijnen bepalen
    for woord in open(tekstbestand, 'r'):
        woord = woord.rstrip('\n')
        rechte_lijnen = aantal_rechte_lijnen(woord, dictionary)

        # enkel woorden toevoegen met 0 rechte lijnen
        if rechte_lijnen == 0:
            verzameling.add(woord)

    return verzameling

def gebalanceerde_lijnen(tekstbestand, dictionary):

    # lege verzameling initialiseren
    verzameling = set()

    # voor elk woord aantal kromme en rechte lijnen bepalen
    for woord in open(tekstbestand, 'r'):
        woord = woord.rstrip('\n')
        rechte_lijnen = aantal_rechte_lijnen(woord, dictionary)
        kromme_lijnen = aantal_kromme_lijnen(woord, dictionary)

        # enkel woorden toevoegen met evenveel kromme als rechte lijnen
        if rechte_lijnen == kromme_lijnen:
            verzameling.add(woord)

    return verzameling",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( comment ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),94,"{""filename"":""Jana Goes/geometrische-letters.py"",""fullName"":""Jana Goes"",""id"":""2459"",""status"":""correct"",""submissionID"":""6749484"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:41:08.000Z"",""labels"":""biol""}"
141,../exam-folder/Hanke Vermeiren/geometrische-letters.py,"def lees_lettertype(bestand):
    #woordenboek
    dict_letters = dict()
    #open bestand en lees lijn voor lijn 
    invoer = open(bestand, 'r')
    for line in invoer:
        #wis new line aan einde
        line = line.replace('\n', '')
        #splits in elementen
        ele1, ele2, ele3 = line.split()
        #ken elementen toe aan hun plaats in woordenboek
        dict_letters[ele1] = (int(ele2), int(ele3))
    return dict_letters

def aantal_rechte_lijnen(woord, woordenboek):
    som = 0
    #voor elke letter in woord check of in keys woordenboek
    for letter in woord:
        if letter in woordenboek:
            #indien geval voeg eerste waarde tuple toe aan som
            som+= woordenboek[letter][0]
    return som

#zelfde als bij vorig enkel hier de tweede waarde uit de tuple
def aantal_kromme_lijnen(woord, woordenboek):
    som = 0
    for letter in woord:
        if letter in woordenboek:
            som+= woordenboek[letter][1]
    return som

def enkel_rechte_lijnen(bestand, woordenboek):
    #maak lege set
    s1 = set()
    #open bestand en loop erdoor lijn voor lijn 
    woorden = open(bestand, 'r')
    for line in woorden:
        #wis new line
        woord = line.replace('\n', '')
        #chech dat er geen kromme lijnen zijn en voeg woord toe aan set
        if aantal_kromme_lijnen(woord, woordenboek) == 0:
            s1.add(woord)
    return s1

#zelfde als vorig functie enkel hier checken voor rechte lijnen
def enkel_kromme_lijnen(bestand, woordenboek):
    s2 = set()
    woorden = open(bestand, 'r')
    for line in woorden:
        woord = line.replace('\n', '')
        if aantal_rechte_lijnen(woord, woordenboek) == 0:
            s2.add(woord)
    return s2

#zelfde als vorige functies maar hier checken dat lijnen gelijk zijn 
def gebalanceerde_lijnen(bestand, woordenboek):
    s3 = set()
    woorden = open(bestand, 'r')
    for line in woorden:
        woord = line.replace('\n', '')
        if aantal_rechte_lijnen(woord, woordenboek) == aantal_kromme_lijnen(woord, woordenboek) :
            s3.add(woord)
    return s3",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( comment ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( tuple ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ( string ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ( string ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ( string ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),100,"{""filename"":""Hanke Vermeiren/geometrische-letters.py"",""fullName"":""Hanke Vermeiren"",""id"":""12127"",""status"":""correct"",""submissionID"":""6748067"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:06:50.000Z"",""labels"":""keuz""}"
142,../exam-folder/Sebastian Wylleman/geometrische-letters.py,"'''
>>> font = read_font('font.txt')
>>> font['E']
(4, 0)
>>> font['R']
(2, 1)
>>> font['G']
(1, 1)
>>> font['O']
(0, 1)

>>> line_count('ERGONOMICS', font)
(17, 6)
>>> count_straight_lines('ERGONOMICS', font)
17
>>> count_curved_lines('ERGONOMICS', font)
6

>>> straight_lines_only('dictionary.txt', font) == {'ALKALINE', 'MILLENNIAL', 'INFINITELY'}
True
>>> curved_lines_only('dictionary.txt', font) == {'COCCUS', 'COUSCOUS'}
True
>>> balanced_lines('dictionary.txt', font) == {'AUGUSTUS', 'CROSSROAD', 'SUDOKU', 'COLUMBUS', 'PROCESSORS'}
True

'''

def read_font(textfile):

    lib = {}                                                #Initialiseer dict

    with open(textfile) as alpha:
        for letter in alpha:
            letter = letter.rstrip('\n')                    #kuis lijn van backspace
            letter, straight, curve = letter.split(' ')     #tuple unpacking
            lib[letter] = (int(straight), int(curve))       #in dict steken

    return lib

def count_straight_lines(word, font):

    count = 0                                               #initialiseer counter

    for letter in word:
        if letter.isalpha():                                #check if letter, anders next
            straight, _ = font[letter]                      #neem eerste element van font[letter]
            count += straight                               #tel bij counter

    return count

def count_curved_lines(word, font):                         #idem als vorige functie, maar neem tweede element van font[letter]

    count = 0

    for letter in word:
        if letter.isalpha():
            _, curved = font[letter]
            count += curved

    return count

def line_count(word, font):                                 #samenvoeging van vorige 2 functies

    return (count_straight_lines(word, font), count_curved_lines(word, font))

def straight_lines_only(textfile, font):

    answer = set()                                          #initialiseer set

    with open(textfile) as words:
        for word in words:                                  #overloop ieder woord in de file
            word = word.rstrip('\n')                        #kuisen op backspace
            if count_curved_lines(word, font) == 0:         #indien er geen curved lines zijn: toevoegen aan set
                answer.add(word)

    return answer

def curved_lines_only(textfile, font):                      #idem aan vorige functie, maar met straight lines

    answer = set()
    with open(textfile) as words:
        for word in words:
            word = word.rstrip('\n')
            if count_straight_lines(word, font) == 0:
                answer.add(word)

    return answer

def balanced_lines(textfile, font):                         #idem als vorige functies, maar check if curved = straight

    answer = set()
    with open(textfile) as words:
        for word in words:
            word = word.rstrip('\n')
            if count_straight_lines(word, font) == count_curved_lines(word, font):
                answer.add(word)

    return answer

#een idee, maar te laat om te implementeren:
#er is veel functie duplicatie, dus een boven liggend functie met als extra argument: curved, straight, balanced
#zou deze duplicatie kunnen tegenhouden.",( module ( expression_statement ( string ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( comment ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( tuple ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( comment ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( comment ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( subscript ( identifier ) ( identifier ) ) ) ) ( comment ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( subscript ( identifier ) ( identifier ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( return_statement ( tuple ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( comment ) ( comment ) ( comment ) ),114,"{""filename"":""Sebastian Wylleman/geometrische-letters.py"",""fullName"":""Sebastian Wylleman"",""id"":""12156"",""status"":""correct"",""submissionID"":""6750632"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:14:03.000Z"",""labels"":""keuz""}"
143,../exam-folder/Arthur Mestdagh/geometrische-letters.py,"def read_font(location):
    """"""
    a function read_font that takes the location (str) of a text file containing a font description.
    The function must return a dictionary (dict) that maps each character (str) in the file
    onto a tuple with the number of straight lines (int) and the number of curved lines (int) in the character.

    >>> font = read_font('font.txt')
    >>> font['E']
    (4, 0)
    >>> font['R']
    (2, 1)
    >>> font['G']
    (1, 1)
    >>> font['O']
    (0, 1)
    """"""

    cat = open(location, ""r"")
    d = dict()

    for line in cat:
        symbol = line.split(' ')[0]
        d[symbol] = (int(line.split(' ')[1]), int(line.split(' ')[2].rstrip('\n')))

    return d


def count_straight_lines(w, font: dict):
    """"""
    a function count_straight_lines that takes two arguments
    i) a word w (str)
    ii) a font description F (dict).
    The function must return the number (int) of straight lines used in writing the word w in font F.

    >>> font = read_font('font.txt')
    >>> count_straight_lines('ERGONOMICS', font)
    17
    """"""

    c = 0
    for letter in w:
        if letter in list(font.keys()):
            c += font[letter][0]

    return c

def count_curved_lines(w, font: dict):
    """"""
        a function count_curved_lines that takes two arguments
        i) a word w (str)
        ii) a font description F (dict).
        The function must return the number (int) of curved lines used in writing the word w in font F.

        >>> font = read_font('font.txt')
        >>> count_curved_lines('ERGONOMICS', font)
        6
        """"""

    c = 0
    for letter in w:
        if letter in list(font.keys()):
            c += font[letter][1]

    return c


def straight_lines_only(location, f: dict):
    """"""
    a function straight_lines_only that takes two arguments:
    i) the location (str) of a text file containing a word list (one word per line)
    ii) a font description F (dict).
    The function must return a set containing all words (str)
    in the given list that are only written with straight lines in font F.

    >>> font = read_font('font.txt')
    >>> straight_lines_only('dictionary.txt', font)
    {'ALKALINE', 'MILLENNIAL', 'INFINITELY'}
    """"""

    dictionary = open(location, ""r"")
    s = set()
    for word in dictionary:
        if count_curved_lines(word.rstrip('\n'), f) == 0:
            s.add(word.rstrip('\n'))

    return s


def curved_lines_only(location, f: dict):
    """"""
    a function curved_lines_only that takes two arguments:
    i) the location (str) of a text file containing a word list (one word per line)
    ii) a font description F (dict).
    The function must return a set containing all words (str)
    in the given list that are only written with curved lines in font F.

    >>> font = read_font('font.txt')
    >>> curved_lines_only('dictionary.txt', font)
    {'COCCUS', 'COUSCOUS'}
    """"""

    dictionary = open(location, ""r"")
    s = set()
    for word in dictionary:
        if count_straight_lines(word.rstrip('\n'), f) == 0:
            s.add(word.rstrip('\n'))

    return s

def balanced_lines(location, f: dict):
    """"""
    a function balanced_lines that takes two arguments:
    i) the location (str) of a text file containing a word list (one word per line)
    ii) a font description F (dict)
    The function must return a set containing all words (str) in the given list
    that are written with and equal number of straight and curved lines in font F.

    >>> font = read_font('font.txt')
    >>> balanced_lines('dictionary.txt', font)
    {'AUGUSTUS', 'CROSSROAD', 'SUDOKU', 'COLUMBUS', 'PROCESSORS'}
    """"""

    dictionary = open(location, ""r"")
    s = set()
    for word in dictionary:
        if count_straight_lines(word.rstrip('\n'), f) == count_curved_lines(word.rstrip('\n'), f):
            s.add(word.rstrip('\n'))

    return s


if __name__ == '__main__':
    import doctest
    doctest.testmod()
",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ( integer ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( call ( attribute ( subscript ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ( integer ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),111,"{""filename"":""Arthur Mestdagh/geometrische-letters.py"",""fullName"":""Arthur Mestdagh"",""id"":""12159"",""status"":""correct"",""submissionID"":""6749249"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:36:17.000Z"",""labels"":""keuz""}"
144,../exam-folder/Fjonna De Vroe/geometrische-letters.py,"def lees_lettertype(locatie='lettertype.txt'):
    dictionary = {}
    invoer = open(locatie, 'r')
    for regel in invoer:
        letter = ''
        dictionary[regel] = letter
        if letter in dictionary:
            letter += 1
        else:
            letter = 1
    return dictionary


def aantal_rechte_lijnen(woord, locatie='lettertype.txt'):
    rechte_lijnen = 0

    # kolom 1 en 2 = karakter en rechte lijnen

    woord = woord.upper()
    begin = 0
    while woord[begin] in locatie:
        rechte_lijnen += (woord[begin], 2)       # getal kolom 2
        begin += 1
    return rechte_lijnen


def aantal_kromme_lijnen(woord, locatie='lettertype.txt'):
    kromme_lijnen = 0

    # kolom 1 en 3 = karakter en kromme lijnen

    woord = woord.upper()
    begin = 0
    while woord[begin] in locatie:
        kromme_lijnen += (woord[begin], 3)       # getal kolom 3
        begin += 1
    return kromme_lijnen


def enkel_rechte_lijnen(locatie='woordenboek.txt', beschrijving):
    verzameling = set()
    woord = ''
    lettertype = {}
    if aantal_kromme_lijnen(woord, locatie='lettertype.txt') = 0:
        verzameling.add(woord)
    return verzameling


def enkel_kromme_lijnen(locatie='woordenboek.txt', beschrijving):
    verzameling = set()
    woord = ''
    lettertype = {}
    if aantal_rechte_lijnen(woord, locatie='lettertype.txt') = 0:
        verzameling.add(woord)
    return verzameling


def gebalanceerde_lijnen(locatie='woordenboek.txt', beschrijving):
    verzameling = set()
    woord = ''
    lettertype = {}
    if aantal_kromme_lijnen(woord, locatie='lettertype.txt') = aantal_rechte_lijnen(woord, locatie='lettertype.txt'):
        verzameling.add(woord)
    return verzameling
",( module ( function_definition ( identifier ) ( parameters ( default_parameter ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( string ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( identifier ) ) ) ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( integer ) ) ) ) ( else_clause ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( default_parameter ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( while_statement ( comparison_operator ( subscript ( identifier ) ( identifier ) ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( tuple ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( comment ) ( expression_statement ( augmented_assignment ( identifier ) ( integer ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( default_parameter ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( while_statement ( comparison_operator ( subscript ( identifier ) ( identifier ) ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( tuple ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( comment ) ( expression_statement ( augmented_assignment ( identifier ) ( integer ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( default_parameter ( identifier ) ( string ) ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( string ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( if_statement ( call ( identifier ) ( argument_list ( identifier ) ( keyword_argument ( identifier ) ( string ) ) ) ) ( ERROR ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( default_parameter ( identifier ) ( string ) ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( string ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( if_statement ( call ( identifier ) ( argument_list ( identifier ) ( keyword_argument ( identifier ) ( string ) ) ) ) ( ERROR ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( default_parameter ( identifier ) ( string ) ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( string ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( if_statement ( ERROR ( call ( identifier ) ( argument_list ( identifier ) ( keyword_argument ( identifier ) ( string ) ) ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( keyword_argument ( identifier ) ( string ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),82,"{""filename"":""Fjonna De Vroe/geometrische-letters.py"",""fullName"":""Fjonna De Vroe"",""id"":""12116"",""status"":""compilation error"",""submissionID"":""6750224"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:01:55.000Z"",""labels"":""bcbt""}"
145,../exam-folder/Ruben Vercruysse/geometrische-letters.py,"def lees_lettertype(locatie_bestand):
    with open(locatie_bestand) as beschrijving_tekst:
        beschrijving_dict = {}
        for regel in beschrijving_tekst:
            regel = regel.rstrip(""\n"")

            karakter, lijnen_recht, lijnen_krom = regel.split("" "")

            beschrijving_dict[karakter] = int(lijnen_recht), int(lijnen_krom)

    return beschrijving_dict


def aantal_rechte_lijnen(woord, beschrijving_lettertype):
    lijnen_recht = 0
    for char in woord:
        if char in beschrijving_lettertype:
            lijnen_recht += beschrijving_lettertype[char][0]

    return lijnen_recht


def aantal_kromme_lijnen(woord, beschrijving_lettertype):
    lijnen_krom = 0
    for char in woord:
        if char in beschrijving_lettertype:
            lijnen_krom += beschrijving_lettertype[char][1]

    return lijnen_krom


def enkel_lijnen(locatie_bestand, beschrijving_lettertype, teller):
    with open(locatie_bestand) as woorden:
        
        oplossing_set = set()
        for woord in woorden:

            woord = woord.rstrip(""\n"")
            if teller(woord, beschrijving_lettertype) == 0:
                oplossing_set.add(woord)

        return oplossing_set


def enkel_rechte_lijnen(locatie_bestand, beschrijving_lettertype):

    return enkel_lijnen(locatie_bestand, beschrijving_lettertype, aantal_kromme_lijnen)


def enkel_kromme_lijnen(locatie_bestand, beschrijving_lettertype):

    return enkel_lijnen(locatie_bestand, beschrijving_lettertype, aantal_rechte_lijnen)


def gebalanceerde_lijnen(locatie_bestand, beschrijving_lettertype):
    with open(locatie_bestand) as woorden:
        
        oplossing_set = set()
        for woord in woorden:

            woord = woord.rstrip(""\n"")
            if aantal_kromme_lijnen(woord,beschrijving_lettertype) == aantal_rechte_lijnen(woord, beschrijving_lettertype):
                oplossing_set.add(woord)

    return oplossing_set
",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( expression_list ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ( identifier ) ) ( block ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),82,"{""filename"":""Ruben Vercruysse/geometrische-letters.py"",""fullName"":""Ruben Vercruysse"",""id"":""12199"",""status"":""correct"",""submissionID"":""6750088"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:58:18.000Z"",""labels"":""chem""}"
146,../exam-folder/Lore Lamote/geometrische-letters.py,"def lees_lettertype(tekstbestand):
    invoer = open(tekstbestand, 'r')
    regel = invoer.readline()
    dictionary = {}

    while regel:
        lijst_regel = regel.split(' ')
        lijst_regel[-1].rstrip('\n')
        dictionary[lijst_regel[0]] = (int(lijst_regel[1]), int(lijst_regel[2]))
        regel = invoer.readline()

    return dictionary

def aantal_rechte_lijnen(woord_w, beschrijving_lettertype):
    som = 0
    for letter in woord_w:
        tuple_waarden = beschrijving_lettertype.get(letter)
        if tuple_waarden is not None:
            recht, krom = tuple_waarden
            som += recht

    return som

def aantal_kromme_lijnen(woord_w, beschrijving_lettertype):
    som = 0
    for letter in woord_w:
        tuple_waarden = beschrijving_lettertype.get(letter)
        if tuple_waarden is not None:
            recht, krom = tuple_waarden
            som += krom

    return som

def enkel_rechte_lijnen(tekstbestand, beschrijving_lettertype):
# De functie moet een verzameling (set) teruggeven met alle woorden
# (str) uit de gegeven reeks die enkel met rechte lijnen geschreven
# worden in lettertype
    sett = set()
    invoer = open(tekstbestand, 'r')
    regel = invoer.readline()

    while regel:
        regel = regel.rstrip('\n')
        krom = aantal_kromme_lijnen(regel, beschrijving_lettertype)
        if krom == 0:
            sett.add(regel)
        regel = invoer.readline()

    return sett

def enkel_kromme_lijnen(tekstbestand, beschrijving_lettertype):
    sett = set()
    invoer = open(tekstbestand, 'r')
    regel = invoer.readline()

    while regel:
        regel = regel.rstrip('\n')
        recht = aantal_rechte_lijnen(regel, beschrijving_lettertype)
        if recht == 0:
            sett.add(regel)
        regel = invoer.readline()

    return sett

def gebalanceerde_lijnen(tekstbestand, beschrijving_lettertype):
    sett = set()
    invoer = open(tekstbestand, 'r')
    regel = invoer.readline()

    while regel:
        regel = regel.rstrip('\n')
        aantal_recht = aantal_rechte_lijnen(regel, beschrijving_lettertype)
        aantal_krom = aantal_kromme_lijnen(regel, beschrijving_lettertype)
        if aantal_krom == aantal_recht:
            sett.add(regel)
        regel = invoer.readline()

    return sett",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( while_statement ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( call ( attribute ( subscript ( identifier ) ( unary_operator ( integer ) ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( none ) ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( identifier ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( none ) ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( identifier ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( comment ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( while_statement ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( while_statement ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( while_statement ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),122,"{""filename"":""Lore Lamote/geometrische-letters.py"",""fullName"":""Lore Lamote"",""id"":""12202"",""status"":""correct"",""submissionID"":""6749017"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:30:46.000Z"",""labels"":""geog""}"
147,../exam-folder/Eva De Mits/geometrische-letters.py,"def read_font(text_file):
    my_dict = {}
    for line in open(text_file):
        key, value = line[:1], (int(line[2]), int(line[4]))
        my_dict[key] = value
    return my_dict


def count_straight_lines(word, font):
    count = 0
    for letter in word:
        if font.get(letter) is not None:
            count += int(font.get(letter)[0])
    return count


def count_curved_lines(word, font):
    count = 0
    for letter in word:
        if font.get(letter) is not None:
            count += int(font.get(letter)[1])
    return count


def straight_lines_only(words, font):

    return {word.rstrip('\n') for word in open(words) \
            if count_curved_lines(word, font) == 0}


def curved_lines_only(words, font):

    return {word.rstrip('\n') for word in open(words) \
            if count_straight_lines(word, font) == 0}


def balanced_lines(words, font):
    return {word.rstrip('\n') for word in open(words) \
            if count_curved_lines(word, font) == count_straight_lines(word, font)}
",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( expression_list ( subscript ( identifier ) ( slice ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( identifier ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ( none ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( call ( identifier ) ( argument_list ( subscript ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ( integer ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ( none ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( call ( identifier ) ( argument_list ( subscript ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ( integer ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( for_in_clause ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ( if_clause ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( for_in_clause ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ( if_clause ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( for_in_clause ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ( if_clause ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ) ) ) ) ),69,"{""filename"":""Eva De Mits/geometrische-letters.py"",""fullName"":""Eva De Mits"",""id"":""11094"",""status"":""correct"",""submissionID"":""6750364"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:06:51.000Z"",""labels"":""geog""}"
148,../exam-folder/Noor Ghesquiere/geometrische-letters.py,"def lees_lettertype(loc):
    #open het bestand om te lezen
    with open(loc, 'r') as code:
        d = {}
        for regel in code:
            #splits de regels bij de komma om de 3 elementen te scheiden
            r = regel.split()
            #de letter vormt de key
            d[r[0]] = int(r[1]), int(r[2])
    return d

def aantal_rechte_lijnen(woord, d):
    som = 0
    #voor elke letter in het woord
    for w in woord:
        if w in d:
            #het eerste element van de value is het aantal rechte lijnen van de letter
            som += list(d[w])[0]
    return som

def aantal_kromme_lijnen(woord, d):
    som = 0
    for w in woord:
        if w in d:
            # het tweede element van de value is het aantal kromme lijnen van de letter
            som += list(d[w])[1]
    return som

def enkel_rechte_lijnen(loc, d):
    res = set()
    with open(loc, 'r') as reeks:
        for regel in reeks:
            #enkel als het aantal kromme lijnen 0 is, dus enkel rechte lijnen, mag het woord toegevoegd worden aan resulaat
            if aantal_kromme_lijnen(regel.strip(), d) == 0:
                res.add(regel.strip())
    return res

def enkel_kromme_lijnen(loc, d):
    res = set()
    with open(loc, 'r') as reeks:
        for regel in reeks:
            # enkel als het aantal rechte lijnen 0 is, dus enkel kromme lijnen, mag het woord toegevoegd worden aan resulaat
            if aantal_rechte_lijnen(regel.strip(), d) == 0:
                res.add(regel.strip())
    return res

def gebalanceerde_lijnen(loc, d):
    res = set()
    with open(loc, 'r') as reeks:
        for regel in reeks:
            # enkel als het aantal kromme lijnen gelijk is aan het aantal rechte lijnen, mag het woord toegevoegd worden aan het resultaat
            if aantal_rechte_lijnen(regel.strip(), d) == aantal_kromme_lijnen(regel.strip(), d):
                res.add(regel.strip())
    return res",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( comment ) ( block ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( comment ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( expression_list ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( identifier ) ) ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( identifier ) ) ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),92,"{""filename"":""Noor Ghesquiere/geometrische-letters.py"",""fullName"":""Noor Ghesquiere"",""id"":""12203"",""status"":""correct"",""submissionID"":""6749756"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:48:55.000Z"",""labels"":""geog""}"
149,../exam-folder/Rmi Vandewalle/geometrische-letters.py,"def lettertype(invoer):
    #bestanden openen
    with open(invoer, 'r') as f:
        #elke letter gaan interpreteren
        for letter in invoer:
            #aantal rechte en kromme ljnen tellen
            waarden = regel[1:]
    return waarden
def aantal_rechte_lijnen(w, lettertype):
    #optellen van alle rechte lijnen letter per letter 
    letters = list(w)
    aantal_rechte_lijnen = 0
    for letters in woord:
        #de waarden krijgen van rechten en kromme lijnen 
        waarden = lettertype(letters)
        # de kromme lijnen verwerpen en alleem met de rechte lijnen over blijven
        rechte_lijnen = waarden[0:]
        #alle rechte lijnen optellen
        aantal_rechte_lijnen += rechte_lijnen
    return aantal_rechte_lijnnen
def aantal_kromme_lijnen(w, lettertype):
    #optellen van alle kromme lijnen letter per letter 
    letters = list(w)
    aantal_kromme_lijnen = 0
    for letters in woord:
        #de waarden krijgen van rechte en kromme lijnen
        waarden = lettertype(letters)
        #de rechte lijnen verwerpen zodat alleen de kromme lijnen over blijven
        kromme_lijnen = waarden[:-1]
        #alle kromme lijnen optellen 
        aantal_kromme_lijnen += kromme_lijnen
    return aantal_kromme_lijnen
def enkel_rechte_lijnen('woordenboek.txt', lettertype):
    #gevraagd is een verzameling
    verzameling = set()
    #bestand openen
    with open(woordenboek.txt, 'r') as f:
        #elk woord apart benaderen
        for woord in woordenboek.txt:
            waarden = aantal_kromme_lijnen(woord)
            #enkel de woorden nemen zonder kromme lijnen 
            if waarden == 0:
                verzameling += woord
    return verzameling 
def enkel_kromme_lijnen('woordenboek.txt', lettertype):
    #gevraagd is een verzameling
    verzameling = set()
    #bestand openen
    with open(woordenboek.txt, 'r') as f:
        #elk woord apart benaderen
        for woord in woordenboek.txt:
            waarden = aantal_rechte_lijnen(woord)
            #enkel de woorden nemen zonder rechte lijnen 
            if waarden == 0:
                verzameling += woord
    return verzameling 
def gebalanceerde_lijnen('woordenboek.txt', lettertype):
    #gevraagd is een verzameling
    verzameling = set()
    #bestand openen
    with open(woordenboek.txt, 'r') as f:
        #elk woord apart benaderen
        for woord in woordenboek.txt:
            waarden1 = aantal_rechte_lijnen(woord)
            waarden2 = aantal_kromme_lijnen(woord)
            #enkel de woorden nemen met even veel kromme lijnen als rechte lijnen
            if waarden1 == waarden2:
                verzameling += woord
    return verzameling ",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( comment ) ( block ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( comment ) ( block ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( slice ( integer ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( slice ( integer ) ) ) ) ) ( comment ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ( comment ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( ERROR ( identifier ) ) ( expression_statement ( string ) ) ( ERROR ( identifier ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( attribute ( identifier ) ( identifier ) ) ( string ) ) ) ( identifier ) ) ) ( comment ) ( block ( for_statement ( identifier ) ( attribute ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ( ERROR ( identifier ) ) ( expression_statement ( string ) ) ( ERROR ( identifier ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( attribute ( identifier ) ( identifier ) ) ( string ) ) ) ( identifier ) ) ) ( comment ) ( block ( for_statement ( identifier ) ( attribute ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ( ERROR ( identifier ) ) ( expression_statement ( string ) ) ( ERROR ( identifier ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( attribute ( identifier ) ( identifier ) ) ( string ) ) ) ( identifier ) ) ) ( comment ) ( block ( for_statement ( identifier ) ( attribute ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ),103,"{""filename"":""Rmi Vandewalle/geometrische-letters.py"",""fullName"":""Rmi Vandewalle"",""id"":""12217"",""status"":""compilation error"",""submissionID"":""6750143"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:59:53.000Z"",""labels"":""geog""}"
150,../exam-folder/Matteo Vereertbrugghen/geometrische-letters.py,"def read_font(tekstbestand):
    # defineer de dict die we gaan terug geven
    tabel = {}
    hele_tekst = open(tekstbestand)
    lijn = hele_tekst.readline()
    while lijn:
        # splits de lijn in drie stukken
        drie_delen = lijn.split("" "")
        tabel[drie_delen[0]] = int(drie_delen[1]), int(drie_delen[2].rstrip(""\n""))
        lijn = hele_tekst.readline()
    hele_tekst.close()
    return tabel


def count_straight_lines(woord, dict_met_lijnen):
    """"""
    >>> count_straight_lines('ERGONOMIE', dict_met_lijnen)
    21
    """"""
    uiteindelijk_getal = 0
    # zoek het letter per letter op in de dict
    for letter in woord:
        # letter moet in de dict zitten
        if letter in dict_met_lijnen:
            # zoek het aantal rechte lijnen
            lijnen = dict_met_lijnen[letter]
            uiteindelijk_getal += lijnen[0]
    return uiteindelijk_getal


def count_curved_lines(woord, dict_met_lijnen):
    """"""
    >>> count_curved_lines('ERGONOMIE', dict_met_lijnen)
    4

    """"""
    uiteindelijk_getal = 0
    # zoek het letter per letter op in de dict
    for letter in woord:
        # letter moet in de dict zitten
        if letter in dict_met_lijnen:
            # zoek het aantal curved lijnen
            lijnen = dict_met_lijnen[letter]
            uiteindelijk_getal += lijnen[1]
    return uiteindelijk_getal


def straight_lines_only(tekstbestand_met_woorden, dict_met_lijnen):
    """"""
    >>> straight_lines_only('woordenboek.txt', dict_met_lijnen)
    {'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
    """"""
    # defineer de return
    uiteindelijke_set = set()
    # open het bestand
    hele_tekst = open(tekstbestand_met_woorden)
    lijn = hele_tekst.readline().rstrip(""\n"")
    while lijn:
        # kijk of er curved lijnen zijn
        if count_curved_lines(lijn, dict_met_lijnen) == 0:
            uiteindelijke_set.add(lijn)
        lijn = hele_tekst.readline().rstrip(""\n"")
    hele_tekst.close()
    return uiteindelijke_set


def curved_lines_only(tekstbestand_met_woorden, dict_met_lijnen):
    """"""
    >>> curved_lines_only('woordenboek.txt', dict_met_lijnen)
    {'COCCUS', 'COUSCOUS'}
    """"""
    # defineer de return
    uiteindelijke_set = set()
    # open het bestand
    hele_tekst = open(tekstbestand_met_woorden)
    lijn = hele_tekst.readline().rstrip(""\n"")
    while lijn:
        # kijk of er rechte lijnen zijn
        if count_straight_lines(lijn, dict_met_lijnen) == 0:
            uiteindelijke_set.add(lijn)
        lijn = hele_tekst.readline().rstrip(""\n"")
    hele_tekst.close()
    return uiteindelijke_set


def balanced_lines(tekstbestand_met_woorden, dict_met_lijnen):
    """"""
    >>> balanced_lines('woordenboek.txt', dict_met_lijnen)
    {'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}
    """"""
    # defineer de return
    uiteindelijke_set = set()
    # open het bestand
    hele_tekst = open(tekstbestand_met_woorden)
    lijn = hele_tekst.readline().rstrip(""\n"")
    while lijn:
        # kijk of het aantal rechte lijnen gelijk is aan het aantal kromme
        if count_straight_lines(lijn, dict_met_lijnen) == count_curved_lines(lijn, dict_met_lijnen):
            uiteindelijke_set.add(lijn)
        lijn = hele_tekst.readline().rstrip(""\n"")
    hele_tekst.close()
    return uiteindelijke_set


if __name__ == '__main__':
    import doctest
    doctest.testmod()",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( while_statement ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( expression_list ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( call ( attribute ( subscript ( identifier ) ( integer ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( identifier ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( identifier ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( while_statement ( identifier ) ( comment ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( while_statement ( identifier ) ( comment ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( while_statement ( identifier ) ( comment ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( identifier ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),124,"{""filename"":""Matteo Vereertbrugghen/geometrische-letters.py"",""fullName"":""Matteo Vereertbrugghen"",""id"":""12236"",""status"":""correct"",""submissionID"":""6750286"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:04:10.000Z"",""labels"":""fyss""}"
151,../exam-folder/Ward Van Cauwenberge/geometrische-letters.py,"def lees_lettertype(bestand):
    bestand = open(bestand, 'r').readlines()
    uitkomst = {}
    for lijn in bestand:
        lijn = lijn[:-1]
        sleutel = lijn[0]
        waarde = (int(lijn[2]), int(lijn[-1]))
        uitkomst[sleutel] = waarde
    return uitkomst

def aantal_rechte_lijnen(woord, dictio):
    uitkomst = 0
    for letter in woord:
        if letter.isalpha():
            uitkomst += dictio[letter][0]
    return uitkomst

def aantal_kromme_lijnen(woord, dictio):
    uitkomst = 0
    for letter in woord:
        if letter.isalpha():
            uitkomst += dictio[letter][-1]
    return uitkomst

def enkel_rechte_lijnen(bestand, dictio):
    bestand = open(bestand, 'r').readlines()
    uitkomst = set()
    for woord in bestand:
        woord = woord[:-1]
        waarden = aantal_kromme_lijnen(woord, dictio)
        if waarden == 0:
            uitkomst.add(woord)
    return uitkomst

def enkel_kromme_lijnen(bestand, dictio):
    bestand = open(bestand, 'r').readlines()
    uitkomst = set()
    for woord in bestand:
        woord = woord[:-1]
        waarden = aantal_rechte_lijnen(woord, dictio)
        if waarden == 0:
            uitkomst.add(woord)
    return uitkomst

def gebalanceerde_lijnen(bestand, dictio):
    bestand = open(bestand, 'r').readlines()
    uitkomst = set()
    for woord in bestand:
        woord = woord[:-1]
        waarden1 = aantal_rechte_lijnen(woord, dictio)
        waarden2 = aantal_kromme_lijnen(woord, dictio)
        if waarden1 == waarden2:
            uitkomst.add(woord)
    return uitkomst",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ( expression_statement ( assignment ( identifier ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( unary_operator ( integer ) ) ) ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( identifier ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( unary_operator ( integer ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),96,"{""filename"":""Ward Van Cauwenberge/geometrische-letters.py"",""fullName"":""Ward Van Cauwenberge"",""id"":""8450"",""status"":""correct"",""submissionID"":""6748587"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:20:58.000Z"",""labels"":""geog""}"
152,../exam-folder/Ninke Fant/geometrische-letters.py,"def lees_lettertype(bestand):       #   bestand inlezen en woordenboek er van maken
    invoer = open(bestand, 'r')
    regels = invoer.readlines()
    d1 = {}
    aantal_lijnen = []
    for x in regels:
        x = x.split(' ')
        aantal_lijnen.append(int(x[1]))
        aantal_lijnen.append(int(x[-1].rstrip('\n')))
        d1[x[0]] = tuple(aantal_lijnen)
        aantal_lijnen = []
    return d1

def aantal_rechte_lijnen(woord, beschrijving):
    som = 0
    for x in woord:
        if x.isalpha():         #    enkel letters inlezen
            som += beschrijving[x][0]
    return som

def aantal_kromme_lijnen(woord, beschrijving):
    som = 0
    for x in woord:
        if x.isalpha():
            som += beschrijving[x][1]
    return som

def enkel_rechte_lijnen(locatie, beschrijving):
    rechte = set()
    invoer = open(locatie, 'r')
    regels = invoer.readlines()
    for x in regels:
        krom = aantal_kromme_lijnen(x.rstrip('\n'), beschrijving)
        if krom == 0:           # als aantal nul, gee kromme lijnen en dus toevoegen lijst
            rechte.add(x.rstrip('\n'))
    return rechte

def enkel_kromme_lijnen(locatie, beschrijving):
    krom = set()
    invoer = open(locatie, 'r')
    regels = invoer.readlines()
    for x in regels:
        recht = aantal_rechte_lijnen(x.rstrip('\n'), beschrijving)
        if recht == 0:
            krom.add(x.rstrip('\n'))
    return krom

def gebalanceerde_lijnen(locatie, beschrijving):
    evenveel = set()
    invoer = open(locatie, 'r')
    regels = invoer.readlines()
    for x in regels:
        recht = aantal_rechte_lijnen(x.rstrip('\n'), beschrijving)
        krom = aantal_kromme_lijnen(x.rstrip('\n'), beschrijving)
        if recht == krom:
            evenveel.add(x.rstrip('\n'))
    return evenveel",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( expression_statement ( assignment ( identifier ) ( list ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( identifier ) ( argument_list ( call ( attribute ( subscript ( identifier ) ( unary_operator ( integer ) ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( list ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),115,"{""filename"":""Ninke Fant/geometrische-letters.py"",""fullName"":""Ninke Fant"",""id"":""12284"",""status"":""correct"",""submissionID"":""6750513"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:10:39.000Z"",""labels"":""geog""}"
153,../exam-folder/Lise Goossens/geometrische-letters.py,"def lees_lettertype(file):
    lettertype = open(file, ""r"")
    dic = {}
    for regel in lettertype:
        dic[regel.split()[0]] = (int(regel.split()[1]), int(regel.split()[2]))
    return dic

def aantal_rechte_lijnen(woord, lettertype):
    counter = 0
    for x,y in lettertype.items():
        if x in woord:
            rechte_lijnen = list(y)
            counter += int(rechte_lijnen[0])
        else:
            counter += 0
    return counter

def aantal_kromme_lijnen(woord, lettertype):
    counter = 0
    for x, y in lettertype.items():
        if x in woord:
            rechte_lijnen = list(y)
            counter += int(rechte_lijnen[1])
        else:
            counter += 0
    return counter

def enkel_rechte_lijnen(woordenboek, lettertype):
    woordenboek1 = open(woordenboek, ""r"")
    set = {}
    for regel in woordenboek:
        set()



    counter = 0
    for x, y in lettertype.items():
        if x in woord:
            rechte_lijnen = list(y)
            if rechte_lijnen[1] == 0:
                counter += rechte_lijnen[0]
    return counter




",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( integer ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( pattern_list ( identifier ) ( identifier ) ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ( else_clause ( block ( expression_statement ( augmented_assignment ( identifier ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( pattern_list ( identifier ) ( identifier ) ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ( else_clause ( block ( expression_statement ( augmented_assignment ( identifier ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( call ( identifier ) ( argument_list ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( pattern_list ( identifier ) ( identifier ) ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( subscript ( identifier ) ( integer ) ) ( integer ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),76,"{""filename"":""Lise Goossens/geometrische-letters.py"",""fullName"":""Lise Goossens"",""id"":""12251"",""status"":""runtime error"",""submissionID"":""6750631"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:14:02.000Z"",""labels"":""geog""}"
154,../exam-folder/Damian van Kranen/geometrische-letters.py,"def lees_lettertype(bestand):

    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> lettertype['E']
    (4, 0)
    >>> lettertype['R']
    (2, 1)
    >>> lettertype['G']
    (1, 1)
    >>> lettertype['O']
    (0, 1)
    """"""

    #referentie
    d = {}

    # voor iedere regel in het bestand de informatie van de karakters verkrijgen
    with open(bestand, 'r') as lettertype:
        for regel in lettertype:
            karakter, rechte, kromme = regel.split()
            d[karakter] = int(rechte), int(kromme)
    return d


def aantal_rechte_lijnen(woord, lettertype):

    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> aantal_rechte_lijnen('DROP-OUT', lettertype)
    6
    """"""

    # referentie
    aantal = 0

    # voor iedere letter in het woord het aantal rechte lijnen bepalen en deze optellen
    for letter in woord:
        if letter in lettertype:
            rechte = lettertype[letter][0]
            aantal += rechte
    return aantal


def aantal_kromme_lijnen(woord, lettertype):

    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
    4
    """"""

    # referentie
    aantal = 0

    # voor iedere letter in het woord het aantal kromme lijnen bepalen en deze optellen
    for letter in woord:
        if letter in lettertype:
            kromme = lettertype[letter][1]
            aantal += kromme
    return aantal


def enkel_rechte_lijnen(bestand, lettertype):

    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> enkel_rechte_lijnen('woordenboek.txt', lettertype)
    {'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
    """"""

    # referentie
    w = set()

    # voor ieder woord in het bestand bepalen of het enkel rechte lijnen bevat
    with open(bestand, 'r') as woorden:
        for woord in woorden:
            woord = woord.strip()
            if aantal_kromme_lijnen(woord, lettertype) == 0:
                w.add(woord)
    return w


def enkel_kromme_lijnen(bestand, lettertype):

    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> enkel_kromme_lijnen('woordenboek.txt', lettertype)
    {'COCCUS', 'COUSCOUS'}
    """"""

    # referentie
    w = set()

    # voor ieder woord in het bestand bepalen of het enkel kromme lijnen bevat
    with open(bestand, 'r') as woorden:
        for woord in woorden:
            woord = woord.strip()
            if aantal_rechte_lijnen(woord, lettertype) == 0:
                w.add(woord)
    return w


def gebalanceerde_lijnen(bestand, lettertype):

    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> gebalanceerde_lijnen('woordenboek.txt', lettertype)
    {'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}
    """"""

    # referentie
    w = set()

    # voor ieder woord in het bestand nagaan of het evenveel kromme als rechte lijnen bevat
    with open(bestand) as woorden:
        for woord in woorden:
            woord = woord.strip()
            if aantal_rechte_lijnen(woord, lettertype) == aantal_kromme_lijnen(woord, lettertype):
                w.add(woord)
    return w


if __name__ == '__main__':
    import doctest
    doctest.testmod()
",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( comment ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( expression_list ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),107,"{""filename"":""Damian van Kranen/geometrische-letters.py"",""fullName"":""Damian van Kranen"",""id"":""12298"",""status"":""correct"",""submissionID"":""6749397"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:39:19.000Z"",""labels"":""keuz""}"
155,../exam-folder/Sofie De Boe/geometrische-letters.py,"def lees_lettertype(locatie_tekstbestand):
    tekstbestand = open(locatie_tekstbestand)
    letters = {}
    for lijn in tekstbestand:
        letters[lijn[0]] = (int(lijn[2]), int(lijn[4]))
    return letters


def aantal_rechte_lijnen(woord, lettertype):
    rechte_lijnen = 0
    for letter in woord:
        if letter in lettertype:
            rechte_lijnen += lettertype[letter][0]
    return rechte_lijnen


def aantal_kromme_lijnen(woord, lettertype):
    kromme_lijnen = 0
    for letter in woord:
        if letter in lettertype:
            kromme_lijnen += lettertype[letter][1]
    return kromme_lijnen


def enkel_rechte_lijnen(locatie_tekstbestand, lettertype):
    tekstbestand = open(locatie_tekstbestand)
    juiste_woorden = set()
    for woord in tekstbestand:
        woord = str(woord).rstrip('\n')
        if aantal_kromme_lijnen(woord, lettertype) == 0:
            juiste_woorden.add(woord)
    return juiste_woorden


def enkel_kromme_lijnen(locatie_tekstbestand, lettertype):
    tekstbestand = open(locatie_tekstbestand)
    juiste_woorden = set()
    for woord in tekstbestand:
        woord = str(woord).rstrip('\n')
        if aantal_rechte_lijnen(woord, lettertype) == 0:
            juiste_woorden.add(woord)
    return juiste_woorden


def gebalanceerde_lijnen(locatie_tekstbestand, lettertype):
    tekstbestand = open(locatie_tekstbestand)
    juiste_woorden = set()
    for woord in tekstbestand:
        woord = str(woord).rstrip('\n')
        if aantal_rechte_lijnen(woord, lettertype) == aantal_kromme_lijnen(woord, lettertype):
            juiste_woorden.add(woord)
    return juiste_woorden",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),86,"{""filename"":""Sofie De Boe/geometrische-letters.py"",""fullName"":""Sofie De Boe"",""id"":""12305"",""status"":""correct"",""submissionID"":""6749412"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:39:36.000Z"",""labels"":""chem""}"
156,../exam-folder/Hanne Schokkel/geometrische-letters.py,"def lees_lettertype(filename):
    letterlijst = {}
    for regel in open(filename, ""r""):
        lijn = regel.split(' ')
        character = lijn[0]
        recht = int(lijn[1].strip())
        krom = int(lijn[2].strip())
        if character not in letterlijst:
            letterlijst[character] = recht, krom
    return letterlijst


def aantal_rechte_lijnen(woord, lettertype):
    return aantal_lijnen(woord, lettertype, True)

def aantal_kromme_lijnen(woord, lettertype):
    return aantal_lijnen(woord, lettertype, False)

def aantal_lijnen(woord, lettertype, recht = True):
    aantal = 0
    for c in woord:
        try:
            if recht:
                aantal += lettertype[c][0]
            else:
                aantal += lettertype[c][1]
        except KeyError:
            pass
    return aantal
    
def enkel_rechte_lijnen(locatie, lettertype):
    return enkel(locatie, lettertype)[0]

def enkel_kromme_lijnen(locatie, lettertype):
    return enkel(locatie, lettertype)[1]

def enkel(locatie, lettertype):
    rechtlijst = set()
    kromlijst = set()
    for regel in open(locatie, ""r""):
        woord = regel.strip()
        recht = aantal_rechte_lijnen(woord, lettertype)
        krom = aantal_kromme_lijnen(woord, lettertype)
        if recht > 0 and krom == 0:
            rechtlijst.add(woord)
        if krom > 0 and recht == 0:
            kromlijst.add(woord)
    return rechtlijst, kromlijst
    
def gebalanceerde_lijnen(locatie, lettertype):
    woordenlijst = set()
    for regel in open(locatie, ""r""):
        woord = regel.strip()
        recht = aantal_rechte_lijnen(woord, lettertype)
        krom = aantal_kromme_lijnen(woord, lettertype)
        if recht == krom:
            woordenlijst.add(woord)
    return woordenlijst",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( call ( attribute ( subscript ( identifier ) ( integer ) ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( call ( attribute ( subscript ( identifier ) ( integer ) ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( expression_list ( identifier ) ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ( true ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ( false ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ( default_parameter ( identifier ) ( true ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( try_statement ( block ( if_statement ( identifier ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ( else_clause ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( except_clause ( identifier ) ( block ( pass_statement ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( boolean_operator ( comparison_operator ( identifier ) ( integer ) ) ( comparison_operator ( identifier ) ( integer ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( if_statement ( boolean_operator ( comparison_operator ( identifier ) ( integer ) ) ( comparison_operator ( identifier ) ( integer ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( expression_list ( identifier ) ( identifier ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),101,"{""filename"":""Hanne Schokkel/geometrische-letters.py"",""fullName"":""Hanne Schokkel"",""id"":""12311"",""status"":""correct"",""submissionID"":""6749301"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:37:34.000Z"",""labels"":""chem""}"
157,../exam-folder/Emma Van De Steene/geometrische-letters.py,"def lees_lettertype(bestand: str):
    """""" De lettertype beschrijving uit het bestan uitlezen.
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> lettertype['E']
    (4, 0)
    >>> lettertype['R']
    (2, 1)
    >>> lettertype['G']
    (1, 1)
    >>> lettertype['O']
    (0, 1)
    """"""
    invoer = open(bestand, ""r"")

    uitvoer = {}
    for regel in invoer:
        uitvoer[regel[0]] = (int(regel[2]), int(regel[4]))

    return uitvoer


def aantal_rechte_lijnen(woord: str, beschrijving_lettertype: dict):
    """""" Het aantal rechtelijnen dat zich in de letters in het woord bevinden bepalen.
    >>> lettertype_01 = lees_lettertype('lettertype_01.txt')
    >>> aantal_rechte_lijnen('DROP-OUT', lettertype_01)
    6
    """"""
    aantal_totaal = 0

    # aantal lijnen per letter uit de dict halen en bij het totaal optellen
    for letter in woord:
        if letter.isalpha():
            aantal_letter = beschrijving_lettertype[letter][0]
            aantal_totaal += aantal_letter

    return aantal_totaal


def aantal_kromme_lijnen(woord: str, beschrijving_lettertype: dict):
    """""" Het aantal krommelijnen dat zich in de letters in het woord bevinden bepalen.
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
    4
    """"""
    aantal_totaal = 0

    # aantal lijnen per letter uit de dict halen en bij het totaal optellen
    for letter in woord:
        if letter.isalpha():
            aantal_letter = beschrijving_lettertype[letter][1]
            aantal_totaal += aantal_letter

    return aantal_totaal


def enkel_rechte_lijnen(bestand_woorden: str, beschrijving_lettertype: dict):
    """""" Bepalen welke woorden er bestaan uit letters met enkel rechte lijnen.
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> enkel_rechte_lijnen('woordenboek.txt', lettertype)
    {'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
    """"""
    invoer = open(bestand_woorden, ""r"")

    # ieder woord het aantal kromme bepalen, als dit gelijk is aan nul aan de reeks toevoegen
    rechte_woorden = set()
    for regel in invoer:
        if aantal_kromme_lijnen(regel[:-1], beschrijving_lettertype) == 0:
            rechte_woorden.add(regel[:-1])

    return rechte_woorden


def enkel_kromme_lijnen(bestand_woorden: str, beschrijving_lettertype: dict):
    """""" Bepalen welke woorden er bestaan uit letters met enkel kromme lijnen.
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> enkel_kromme_lijnen('woordenboek.txt', lettertype)
    {'COCCUS', 'COUSCOUS'}
    """"""
    invoer = open(bestand_woorden, ""r"")

    # ieder woord het aantal rechte bepalen, als dit gelijk is aan nul aan de reeks toevoegen
    kromme_woorden = set()
    for regel in invoer:
        if aantal_rechte_lijnen(regel[:-1], beschrijving_lettertype) == 0:
            kromme_woorden.add(regel[:-1])

    return kromme_woorden


def gebalanceerde_lijnen(bestand_woorden: str, beschrijving_lettertype):
    """""" Bepalen welke woorden er bestaan uit evenveel rechte als kromme lijnen.
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> gebalanceerde_lijnen('woordenboek.txt', lettertype)
    {'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}
    """"""
    # woord per woord bepalen hoeveel rechtlijnen en kromme lijnen er zijn. Als deze gelijk zijn het woord toevoegen
    # aan de uitvoer
    invoer = open(bestand_woorden, ""r"")
    uitvoer = set()
    for regel in invoer:
        rechte = aantal_rechte_lijnen(regel[:-1], beschrijving_lettertype)
        kromme = aantal_kromme_lijnen(regel[:-1], beschrijving_lettertype)
        if rechte == kromme:
            uitvoer.add(regel[:-1])

    return uitvoer


if __name__ == '__main__':
    import doctest
    doctest.testmod()
",( module ( function_definition ( identifier ) ( parameters ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( typed_parameter ( identifier ) ( type ( identifier ) ) ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),122,"{""filename"":""Emma Van De Steene/geometrische-letters.py"",""fullName"":""Emma Van De Steene"",""id"":""12322"",""status"":""correct"",""submissionID"":""6750634"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:14:07.000Z"",""labels"":""keuz""}"
158,../exam-folder/Feihong Du/geometrische-letters.py,"def read_font(location):
    ans = {}
    with open(location, encoding='utf-8') as fp:
        lines = fp.readlines()
        for line in lines:
            character, stra_line_size, curv_line_size = line.strip().split(' ')
            ans[character] = (int(stra_line_size), int(curv_line_size))
    return ans


def line_count(word, font):
    temp_ans = [0, 0]
    for c in word:
        if c not in font:
            continue
        temp_ans[0] += font[c][0]
        temp_ans[1] += font[c][1]
    return tuple(temp_ans)


def count_straight_lines(word, font):
    ans = 0
    for c in word:
        if c not in font:
            continue
        ans += font[c][0]
    return ans


def count_curved_lines(word, font):
    ans = 0
    for c in word:
        if c not in font:
            continue
        ans += font[c][1]
    return ans


def straight_lines_only(word_list_location, font):
    ans = set()
    with open(word_list_location, encoding='utf-8') as fp:
        lines = fp.readlines()
        for line in lines:
            word = line.strip()
            if count_curved_lines(word, font) == 0:
                ans.add(word)
    return ans


def curved_lines_only(word_list_location, font):
    ans = set()
    with open(word_list_location, encoding='utf-8') as fp:
        lines = fp.readlines()
        for line in lines:
            word = line.strip()
            if count_straight_lines(word, font) == 0:
                ans.add(word)
    return ans


def balanced_lines(word_list_location, font):
    ans = set()
    with open(word_list_location, encoding='utf-8') as fp:
        lines = fp.readlines()
        for line in lines:
            word = line.strip()
            if count_straight_lines(word, font) == count_curved_lines(word, font):
                ans.add(word)
    return ans",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( keyword_argument ( identifier ) ( string ) ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( tuple ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( list ( integer ) ( integer ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( continue_statement ) ) ) ( expression_statement ( augmented_assignment ( subscript ( identifier ) ( integer ) ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( expression_statement ( augmented_assignment ( subscript ( identifier ) ( integer ) ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( continue_statement ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( continue_statement ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( keyword_argument ( identifier ) ( string ) ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( keyword_argument ( identifier ) ( string ) ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( keyword_argument ( identifier ) ( string ) ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),126,"{""filename"":""Feihong Du/geometrische-letters.py"",""fullName"":""Feihong Du"",""id"":""12162"",""status"":""correct"",""submissionID"":""6749927"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:53:46.000Z"",""labels"":""stat""}"
159,../exam-folder/Sander De Ruyter/geometrische-letters.py,"def lees_lettertype(readfile):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> lettertype['E']
    (4, 0)
    >>> lettertype['R']
    (2, 1)
    >>> lettertype['G']
    (1, 1)
    >>> lettertype['O']
    (0, 1)
    """"""
    dictio = {}
    reader = open(readfile, 'r')
    for line in reader:
        withoutnewline = line.replace(""\n"", """")
        dictio[withoutnewline[0]] = (int(withoutnewline[2]), int(withoutnewline[4]))
    reader.close()
    dictio['-'] = (1 ,0)

    return dictio

def aantal_rechte_lijnen(woord, lettertype):
    """"""
    >>> aantal_rechte_lijnen('print-outs', lettertype)
    24
    >>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
    21
    >>> aantal_rechte_lijnen('print-outs', lettertype_02)
    24
    """"""
    woord = woord.upper()
    rechtelijnen = 0
    for letter in woord:
        tupleletter = lettertype[letter]
        rechtelijnen += tupleletter[0]

    return rechtelijnen



def aantal_kromme_lijnen(woord, lettertype):
    """"""
    >>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
    4
    """"""
    woord = woord.upper()
    krommelijnen = 0
    for letter in woord:
        tupleletter = lettertype[letter]
        krommelijnen += tupleletter[1]

    return krommelijnen

def enkel_rechte_lijnen(readfile, lettertype):
    """"""
    >>> enkel_rechte_lijnen('woordenboek.txt', lettertype)
    {'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
    """"""
    enkelrechtelijnenlijst = []
    reader = open(readfile, 'r')
    for line in reader:
        withoutnewline = line.replace(""\n"", """")
        if aantal_rechte_lijnen(withoutnewline, lettertype) != 0 and aantal_kromme_lijnen(withoutnewline, lettertype) == 0:
            enkelrechtelijnenlijst.append(withoutnewline)
    reader.close()

    return set(enkelrechtelijnenlijst)

def enkel_kromme_lijnen(readfile, lettertype):
    """"""
    >>> enkel_kromme_lijnen('woordenboek.txt', lettertype)
    {'COCCUS', 'COUSCOUS'}
    """"""
    enkelkrommelijnenlijst = []
    reader = open(readfile, 'r')
    for line in reader:
        withoutnewline = line.replace(""\n"", """")
        if aantal_kromme_lijnen(withoutnewline, lettertype) != 0 and aantal_rechte_lijnen(withoutnewline,
                                                                                          lettertype) == 0:
            enkelkrommelijnenlijst.append(withoutnewline)
    reader.close()

    return set(enkelkrommelijnenlijst)

def gebalanceerde_lijnen(readfile, lettertype):
    """"""
    >>> gebalanceerde_lijnen('woordenboek.txt', lettertype)
    {'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}
    """"""
    gebalanceerdelijnenlijst = []
    reader = open(readfile, 'r')
    for line in reader:
        withoutnewline = line.replace(""\n"", """")
        if aantal_kromme_lijnen(withoutnewline, lettertype) == aantal_rechte_lijnen(withoutnewline,lettertype):
            gebalanceerdelijnenlijst.append(withoutnewline)
    reader.close()

    return set(gebalanceerdelijnenlijst)",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( string ) ) ( tuple ( integer ) ( integer ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( identifier ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( identifier ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( list ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ( string ) ) ) ) ) ( if_statement ( boolean_operator ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( list ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ( string ) ) ) ) ) ( if_statement ( boolean_operator ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( list ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ( string ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ),113,"{""filename"":""Sander De Ruyter/geometrische-letters.py"",""fullName"":""Sander De Ruyter"",""id"":""12013"",""status"":""runtime error"",""submissionID"":""6750590"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:12:41.000Z"",""labels"":""stat""}"
160,../exam-folder/Jakob Robbe Vermeulen/geometrische-letters.py,"def lees_lettertype(file):
    tekst_bestand = open(file, 'r')                 # de file wordt geopend
    vertaling = tekst_bestand.readlines()           #de file wordt regel per regel opgeslaan
    tekst_bestand.close()
    dict = {}
    for i in vertaling:                             #de drie waarden, de letter, en de twee waarden worden in een lijst gestoken
        lijst = i.split()
        dict[lijst[0]] = (int(lijst[1]), int(lijst[2]))         

    return dict

def aantal_rechte_lijnen(woord, lettertype):
    rechte_lijnen = 0
    woord = ''.join(filter(str.isalnum, woord))  #hiermee worden alle non alphabetische karakters verwijdert
    for i in woord:                                #elke letter wordt appart bekeken
        rechte_lijnen += lettertype[i][0]          #er wordt uit de tuple de waarde voor het aantal rechte lijnen opgeropen
    return rechte_lijnen                           #deze worden opgeteld bij 'rechte lijnen'

def aantal_kromme_lijnen(woord, lettertype):        #idem vorige stuk, enkel worden de waarden voor het aantal 
    kromme_lijnen = 0                               # kromme lijnen bekeken
    woord = ''.join(filter(str.isalnum, woord))
    for i in woord:
        kromme_lijnen += lettertype[i][1]
    return kromme_lijnen

def enkel_rechte_lijnen(file, lettertype):
    tekst_bestand = open(file, 'r')
    woorden = tekst_bestand.readlines()
    tekst_bestand.close()
    reeks = set()
    for i in woorden:                                           #de woorden in de file worden een per een bekeken
        if aantal_kromme_lijnen(i.rstrip(), lettertype) == 0:   #er wordt gekeken als er kromme lijnen in het woordt zitten
            reeks.add(i.rstrip())                               #zo ja, dan worden deze bij de set toegevoegt
    return reeks

def enkel_kromme_lijnen(file, lettertype):
    tekst_bestand = open(file, 'r')
    woorden = tekst_bestand.readlines()
    tekst_bestand.close()
    reeks = set()
    for i in woorden:                                           #de woorden in de file worden een per een bekeken   
        if aantal_rechte_lijnen(i.rstrip(), lettertype) == 0:   #er wordt gekeken als er rechte lijnen in het woordt zitten
            reeks.add(i.rstrip())                               #zo ja, dan worden deze bij de set toegevoegt
    return reeks

def gebalanceerde_lijnen(file, lettertype):
    tekst_bestand = open(file, 'r')
    woorden = tekst_bestand.readlines()
    tekst_bestand.close()
    reeks = set()
    for i in woorden:                                           #er wordt gekeken als het aantal kromme en rechte lijnen gelijk is
        if aantal_kromme_lijnen(i.rstrip(), lettertype) == aantal_rechte_lijnen(i.rstrip(), lettertype):
            reeks.add(i.rstrip())
    return reeks",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( comment ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( string ) ( identifier ) ) ( argument_list ( call ( identifier ) ( argument_list ( attribute ( identifier ) ( identifier ) ) ( identifier ) ) ) ) ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( comment ) ) ) ( return_statement ( identifier ) ) ( comment ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( string ) ( identifier ) ) ( argument_list ( call ( identifier ) ( argument_list ( attribute ( identifier ) ( identifier ) ) ( identifier ) ) ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ) ( integer ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ) ( integer ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),113,"{""filename"":""Jakob Robbe Vermeulen/geometrische-letters.py"",""fullName"":""Jakob Robbe Vermeulen"",""id"":""12655"",""status"":""correct"",""submissionID"":""6748918"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:28:22.000Z"",""labels"":""fyss""}"
161,../exam-folder/Matisse de Vreugd/geometrische-letters.py,"""""""
>>> lettertype = lees_lettertype('lettertype.txt')
>>> lettertype['E']
(4, 0)
>>> lettertype['R']
(2, 1)
>>> lettertype['G']
(1, 1)
>>> lettertype['O']
(0, 1)

>>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
21
>>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
4

>>> enkel_rechte_lijnen('woordenboek.txt', lettertype)
{'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
>>> enkel_kromme_lijnen('woordenboek.txt', lettertype)
{'COCCUS', 'COUSCOUS'}
>>> gebalanceerde_lijnen('woordenboek.txt', lettertype)
{'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}
""""""


def lees_lettertype(locatie):
    with open(locatie, 'r') as file:
        woordenboek = {}
        for i in file:
            # elke getal voor een rechte/kromme lijn staat op positie 2 resp. 4
            nieuwe_tuple = (int(i[2]), int(i[4]))
            woordenboek[i[0]] = nieuwe_tuple

    return woordenboek


# hulpfunctie waarin het gevraagd aantal lijnen wordt bepaald
def aantal_lijnen(woord, lettertype, soort='krom'):
    rechte_som = 0
    kromme_som = 0
    for i in woord:
        if i not in lettertype:
            recht, krom = 0, 0
        else:
            recht, krom = lettertype[i]
        rechte_som += recht
        kromme_som += krom

    return rechte_som if soort == 'recht' else kromme_som


def aantal_rechte_lijnen(woord, lettertype):
    return aantal_lijnen(woord, lettertype, 'recht')


def aantal_kromme_lijnen(woord, lettertype):
    return aantal_lijnen(woord, lettertype)


# hulpfunctie voor enkel_kromme/rechte/gebalanceerde_lijnen
def enkel_lijnen(locatie, lettertype, soort='kromme'):
    verzameling_rechte = set()
    verzameling_kromme = set()
    verzameling_gebalanceerd = set()
    with open(locatie, 'r') as file:
        for i in file:
            if aantal_rechte_lijnen(i, lettertype) == 0:
                verzameling_kromme.add(i.strip())
            elif aantal_kromme_lijnen(i, lettertype) == 0:
                verzameling_rechte.add(i.strip())
            elif aantal_kromme_lijnen(i, lettertype) == aantal_rechte_lijnen(i, lettertype):
                verzameling_gebalanceerd.add(i.strip())

    if soort == 'recht':
        return verzameling_rechte
    elif soort == 'gebalanceerd':
        return verzameling_gebalanceerd
    
    return verzameling_kromme


def enkel_kromme_lijnen(locatie, lettertype):
    return enkel_lijnen(locatie, lettertype)


def enkel_rechte_lijnen(locatie, lettertype):
    return enkel_lijnen(locatie, lettertype, 'recht')


def gebalanceerde_lijnen(locatie, lettertype):
    return enkel_lijnen(locatie, lettertype, 'gebalanceerd')
    

if __name__ == '__main__':
    import doctest
    doctest.testmod()",( module ( expression_statement ( string ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( identifier ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ( default_parameter ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( expression_list ( integer ) ( integer ) ) ) ) ) ( else_clause ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( subscript ( identifier ) ( identifier ) ) ) ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ( return_statement ( conditional_expression ( identifier ) ( comparison_operator ( identifier ) ( string ) ) ( identifier ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ( string ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ) ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ( default_parameter ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( elif_clause ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ) ( elif_clause ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ) ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( return_statement ( identifier ) ) ) ( elif_clause ( comparison_operator ( identifier ) ( string ) ) ( block ( return_statement ( identifier ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ( string ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ( string ) ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),100,"{""filename"":""Matisse de Vreugd/geometrische-letters.py"",""fullName"":""Matisse de Vreugd"",""id"":""12714"",""status"":""correct"",""submissionID"":""6748736"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:23:50.000Z"",""labels"":""chem""}"
162,../exam-folder/Ewaut Pauwels/geometrische-letters.py,"def lees_lettertype(bestand):

    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> lettertype['E']
    (4, 0)
    >>> lettertype['R']
    (2, 1)
    >>> lettertype['G']
    (1, 1)
    >>> lettertype['O']
    (0, 1)
    """"""
    dic = {}
    for regel in open(bestand, 'r'):
        lijst = []
        regel = regel.rstrip('\n')
        lijst.append(int(regel[2]))
        lijst.append(int(regel[4]))
        dic[regel[0]] = tuple(lijst)
    return dic

def aantal_rechte_lijnen(woord, lettertype):

    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
    21
    """"""
    rechte_lijnen = 0
    for kar in woord:
        if kar.isalpha():
            rechte_lijnen += lettertype[kar][0]
    return rechte_lijnen

def aantal_kromme_lijnen(woord, lettertype):

    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
    4
    """"""

    kromme_lijnen = 0
    for kar in woord:
        if kar.isalpha():
            kromme_lijnen += lettertype[kar][1]
    return kromme_lijnen

def enkel_rechte_lijnen(bestand, lettertype):

    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> enkel_rechte_lijnen('woordenboek.txt', lettertype)
    {'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
    """"""
    woorden = set()
    for regel in open(bestand, 'r'):
        regel = regel.rstrip('\n')
        if aantal_kromme_lijnen(regel, lettertype) == 0:
            woorden.add(regel)
    return woorden


def enkel_kromme_lijnen(bestand, lettertype):

    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> enkel_kromme_lijnen('woordenboek.txt', lettertype)
    {'COCCUS', 'COUSCOUS'}
    """"""
    woorden = set()
    for regel in open(bestand, 'r'):
        regel = regel.rstrip('\n')
        if aantal_rechte_lijnen(regel, lettertype) == 0:
            woorden.add(regel)
    return woorden

def gebalanceerde_lijnen(bestand, lettertype):

    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> gebalanceerde_lijnen('woordenboek.txt', lettertype)
    {'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}
    """"""

    woorden = set()

    for regel in open(bestand, 'r'):
        regel = regel.rstrip('\n')
        if aantal_rechte_lijnen(regel, lettertype) == aantal_kromme_lijnen(regel, lettertype):
            woorden.add(regel)
    return woorden",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( list ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),89,"{""filename"":""Ewaut Pauwels/geometrische-letters.py"",""fullName"":""Ewaut Pauwels"",""id"":""8343"",""status"":""correct"",""submissionID"":""6749391"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:39:03.000Z"",""labels"":""bcbt""}"
163,../exam-folder/Pieter Van Rompaey/geometrische-letters.py,"def lees_lettertype(locatie_bestand):
    bestand = open(locatie_bestand, ""r"")
    letters = {}
    for i in bestand:
        i = i.strip()
        letter = i[0]
        if letter not in letters:
             letters[letter] = (int(i[2]), int(i[4]))

    return letters

def aantal_rechte_lijnen(woord_str, beschrijving_lettertype_dict):
    import string
    som = 0
    woord = """"
    for i in woord_str:
        if i in string.ascii_lowercase or i in string.ascii_uppercase:
            woord+=i
    for i in woord:
        waarde_i = beschrijving_lettertype_dict[i][0]
        som += waarde_i
    return som

def aantal_kromme_lijnen(woord_str, beschrijving_lettertype_dict):
    import string
    som = 0
    woord = """"
    for i in woord_str:
        if i in string.ascii_lowercase or i in string.ascii_uppercase:
            woord += i
    for i in woord:
        waarde_i = beschrijving_lettertype_dict[i][1]
        som += waarde_i
    return som

def enkel_rechte_lijnen(lokatie, lettertype_dict):
    bestand = open(lokatie, ""r"")
    rechte_woorden = set()
    for i in bestand:
        woorden = i.split()
        for _ in woorden:
            if aantal_kromme_lijnen(_, lettertype_dict) == 0:
                rechte_woorden.add(_)
    return rechte_woorden

def enkel_kromme_lijnen(lokatie, lettertype_dict):
    bestand = open(lokatie, ""r"")
    kromme_woorden = set()
    for i in bestand:
        woorden = i.split()
        for _ in woorden:
            if aantal_rechte_lijnen(_, lettertype_dict) == 0:
                kromme_woorden.add(_)
    return kromme_woorden

def gebalanceerde_lijnen(lokatie, lettertype):
    bestand = open(lokatie, ""r"")
    woorden = set()
    for i in bestand:
        i = i.strip()
        if aantal_kromme_lijnen(i, lettertype) == aantal_rechte_lijnen(i, lettertype):
            woorden.add(i)
    return woorden


",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( expression_statement ( assignment ( identifier ) ( string ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( boolean_operator ( comparison_operator ( identifier ) ( attribute ( identifier ) ( identifier ) ) ) ( comparison_operator ( identifier ) ( attribute ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( expression_statement ( assignment ( identifier ) ( string ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( boolean_operator ( comparison_operator ( identifier ) ( attribute ( identifier ) ( identifier ) ) ) ( comparison_operator ( identifier ) ( attribute ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),104,"{""filename"":""Pieter Van Rompaey/geometrische-letters.py"",""fullName"":""Pieter Van Rompaey"",""id"":""11815"",""status"":""correct"",""submissionID"":""6750552"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:11:47.000Z"",""labels"":""geol""}"
164,../exam-folder/Kian Simoens/geometrische-letters.py,"def lees_lettertype(locatie):
    dict = { }
    with open(locatie,'r') as bestand:
        for lijn in bestand:
            #een lijst maken met de waarden per lijn
            letter,recht,krom = lijn.rstrip(""\n"").split("" "")
            #Elke letter initialiseren in de dictionary met bijbehorende waarde
            dict[letter] = (int(recht),int(krom))
    return dict

def aantal_rechte_lijnen(woord,beschrijving):
    aantal_recht = 0
    for letter in woord:
        #alleen als de letter in de dictionary zit, mag de bijbehoorende waarde toegevoegd worden
        if letter in beschrijving:
         aantal_recht += beschrijving[letter][0]
    return aantal_recht

def aantal_kromme_lijnen(woord,beschrijving):
    aantal_krom = 0
    for letter in woord:
        if letter in beschrijving:
            aantal_krom += beschrijving[letter][-1]
    return aantal_krom

def enkel_rechte_lijnen(locatie,beschrijving):
    #verzameling aanmaken
    enkel_recht = set()
    with open(locatie,'r') as bestand:
        for lijn in bestand:
            woord = lijn.rstrip(""\n"")
            #Het aantal kromme lijnen bekijken (met behulp van vorige functie), als dit 0 is, dan pas toevoegen aan verzameling
            if aantal_kromme_lijnen(woord,beschrijving) == 0:
                enkel_recht.add(woord)
    return enkel_recht

def enkel_kromme_lijnen(locatie,beschrijving):
    enkel_krom = set()
    with open(locatie, 'r') as bestand:
        for lijn in bestand:
            woord = lijn.rstrip(""\n"")
            if aantal_rechte_lijnen(woord, beschrijving) == 0:
                enkel_krom.add(woord)
    return enkel_krom

def gebalanceerde_lijnen(locatie,beschrijving):
    evenveel = set()
    with open(locatie, 'r') as bestand:
        for lijn in bestand:
            woord = lijn.rstrip(""\n"")
            if aantal_rechte_lijnen(woord, beschrijving) == aantal_kromme_lijnen(woord,beschrijving):
                evenveel.add(woord)
    return evenveel",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( tuple ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( unary_operator ( integer ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),97,"{""filename"":""Kian Simoens/geometrische-letters.py"",""fullName"":""Kian Simoens"",""id"":""12933"",""status"":""correct"",""submissionID"":""6749891"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:52:43.000Z"",""labels"":""fyss""}"
165,../exam-folder/Quentin Staelens/geometrische-letters.py,"def lees_lettertype(link):
    tekst = open(link) # hier openen we de link
    d = {} # hier maken we een dictionary aan 
    for zin in tekst:
        d[zin[0]] = (int(zin[2]), int(zin[4]))     #hier gaan we voor elke zin van het bestand, de letter gelijkstellen aan het aantal recht en kromme lijnen
    return d
    
def aantal_rechte_lijnen(woord, lettertype):
    aantal = 0
    for letter in woord:
        if letter in lettertype.keys():     # hier gaan we kijken of de letter van het woord wel een key is van de dictionary, moesten we dit niet doen dan kunnen we voor sommige elementen niets kunnen teruggeven
            aantal += lettertype[letter][0]  #hier nemen we het aantal rechte lijnen van de letter en voegen het toe aan het totaal 'aantal'
    return aantal
    
def aantal_kromme_lijnen(woord, lettertype):
    aantal = 0
    for letter in woord:
        if letter in lettertype.keys(): # hier gaan we kijken of de letter van het woord wel een key is van de dictionary, moesten we dit niet doen dan kunnen we voor sommige elementen niets kunnen teruggeven
            aantal += lettertype[letter][1] #hier nemen we het aantal kromme lijnen van de letter en voegen het toe aan het totaal 'aantal'
    return aantal
    
              
def enkel_rechte_lijnen(link, lettertype):
    woordenboek = open(link)    #we openen de link om de woorden te zien
    woorden = set() 
    for woord in woordenboek:
        if aantal_kromme_lijnen(woord.strip(), lettertype) == 0:     # we gaan voor elk woord van het woordenboek kijken of het enkel rechte lijnen geeft dus aantal kromme lijnen moet 0 zijn
            woorden.add(woord.strip())   #als het geen kromme lijnen heeft dan voegen we het toe aan de set
    return woorden 
    
def enkel_kromme_lijnen(link, lettertype):
    woordenboek = open(link)
    woorden = set()
    for woord in woordenboek:
        if aantal_rechte_lijnen(woord.strip(), lettertype) == 0: # we gaan voor elk woord van het woordenboek kijken of het enkel kromme lijnen geeft dus aantal rechte lijnen moet 0 zijn
            woorden.add(woord.strip())  #als het geen recht lijnen heeft dan voegen we het toe aan de set
    return woorden
        
def gebalanceerde_lijnen(link, lettertype):
    woordenboek = open(link)
    woorden = set()
    for woord in woordenboek:
        if aantal_kromme_lijnen(woord.strip(), lettertype) == aantal_rechte_lijnen(woord.strip(), lettertype): # we gaan voor elk woord van het woordenboek kijken of het  kromme lijnen gelijk is aan het aantal rechte lijnen 
            woorden.add(woord.strip()) #als het evenveel recht lijnen als kromme lijnen heeft dan voegen we het toe aan de set
    return woorden",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ( comment ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ) ( integer ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ) ( integer ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),94,"{""filename"":""Quentin Staelens/geometrische-letters.py"",""fullName"":""Quentin Staelens"",""id"":""12222"",""status"":""correct"",""submissionID"":""6748424"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:17:13.000Z"",""labels"":""fyss""}"
166,../exam-folder/Maarten Minnaert/geometrische-letters.py,"def lees_lettertype(bestand):
    beschrijf = dict()
    for line in open(bestand):
        a , b , c = line.split()
        beschrijf[a] = int(b),int(c)
    return beschrijf
    
def aantal_rechte_lijnen(woord,beschrijf):
    aantal_recht = int()
    for letter in woord:
        if str(letter).isalpha():
            aantal_recht += beschrijf[letter][0]
    return aantal_recht
    
def aantal_kromme_lijnen(woord,beschrijf):
    aantal_recht = int()
    for letter in woord:
        if str(letter).isalpha():
            aantal_recht += beschrijf[letter][1]
    return aantal_recht
    
def enkel_rechte_lijnen(bestand,beschrijf):
    verzameling = set()
    for woord in open(bestand):
        if aantal_kromme_lijnen(woord,beschrijf) == 0:
            verzameling.add(woord[:-1])
    return verzameling

def enkel_kromme_lijnen(bestand,beschrijf):
    verzameling = set()
    for woord in open(bestand):
        if aantal_rechte_lijnen(woord,beschrijf) == 0:
            verzameling.add(woord[:-1])
    return verzameling

def gebalanceerde_lijnen(bestand,beschrijf):
    verzameling = set()
    for woord in open(bestand):
        if aantal_rechte_lijnen(woord,beschrijf) == aantal_kromme_lijnen(woord,beschrijf):
            verzameling.add(woord[:-1])
    return verzameling

",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ( identifier ) ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( expression_list ( call ( identifier ) ( argument_list ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),91,"{""filename"":""Maarten Minnaert/geometrische-letters.py"",""fullName"":""Maarten Minnaert"",""id"":""12939"",""status"":""correct"",""submissionID"":""6749091"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:32:38.000Z"",""labels"":""geol""}"
167,../exam-folder/Hannelore Van Haelst/geometrische-letters.py,"def lees_lettertype(locatie_bestand):
    input = open(locatie_bestand, 'r')
    dictionary = {}
    for regel in input: # regel per regel het bestand overlopen
        regel = regel.rstrip('\n') # de newline uit de regel halen
        sleutel = regel[0] # letter is het eerste element van de regel (als je van 1 begint te tellen)
        r_lijnen = int(regel[2]) # aantal rechte lijnen is het derde element van de regel (als je van 1 begint te tellen)
        k_lijnen = int(regel[4]) # aantal kromme lijnen is het vijfde element van de regel (als je van 1 begint te tellen)
        dictionary[sleutel] = (r_lijnen, k_lijnen)
    return dictionary
def aantal_rechte_lijnen(woord, lettertype): # telt het aantal rechte lijnen van een woord in een bepaald lettertype
    aantal = 0
    for letter in woord:
        if letter in list(lettertype.keys()): # niet in het lettertype? letter overslaan
            aantal += lettertype[letter][0] # aantal rechte lijnen is het eerste element van de tuple bij die letter
    return aantal
def aantal_kromme_lijnen(woord, lettertype): # zelfde strategie als bij de rechte lijnen
    aantal = 0
    for letter in woord:
        if letter in list(lettertype.keys()):
            aantal += lettertype[letter][-1]
    return aantal
def enkel_rechte_lijnen(locatie_bestand, lettertype): # telt het aantal woorden in een bestand die alleen maar uit rechte lijnen bestaan
    input = open(locatie_bestand, 'r')
    output = set()
    for woord in input:
        woord = woord.rstrip('\n') # newline uit de regel halen
        if aantal_kromme_lijnen(woord, lettertype) == 0:
            output.add(woord)
    return output
def enkel_kromme_lijnen(locatie_bestand, lettertye): # zelfde strategie als bij de rechte lijnen
    input = open(locatie_bestand, 'r')
    output = set()
    for woord in input:
        woord = woord.rstrip('\n')
        if aantal_rechte_lijnen(woord, lettertye) == 0:
            output.add(woord)
    return output
def gebalanceerde_lijnen(locatie_bestand, lettertype): # evenveel rechte als kromme lijnen in het bestand
    output = set()
    input = open(locatie_bestand, 'r')
    for woord in input:
        woord = woord.rstrip('\n')
        if aantal_rechte_lijnen(woord, lettertype) == aantal_kromme_lijnen(woord, lettertype):
            output.add(woord)
    return output",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( subscript ( identifier ) ( identifier ) ) ( tuple ( identifier ) ( identifier ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( unary_operator ( integer ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),101,"{""filename"":""Hannelore Van Haelst/geometrische-letters.py"",""fullName"":""Hannelore Van Haelst"",""id"":""12944"",""status"":""correct"",""submissionID"":""6749789"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:50:04.000Z"",""labels"":""fyss""}"
168,../exam-folder/n/a/geometrische-letters.py,"def lees_lettertype(locatie):
    #maak een lege dictionary
    dict = {}
    # open de locatie en noem het file
    with open(locatie, 'r') as file:
        for line in file:
            # na elke line gelezen te hebben, doe de '\n' weg op het einde
            line.replace('\n', '')
            # geef aan de value een tuple
            dict[line.split()[0]] = (int(line.split()[1]), int(line.split()[2]))
    return dict

def aantal_rechte_lijnen(woord, beschrijving):
    som = 0
    for letter in woord:
        # na elke letter gelezen te hebben, kijk of het daadwerkelijk een letter is
        if letter.isalpha():
            # voeg aan de som de key toe van het aantal lijnen
            som += beschrijving[letter][0]
    return som
# zo goed als hetzelfe als hierboven
def aantal_kromme_lijnen(woord, beschrijving):
    som = 0
    for letter in woord:
        if letter.isalpha():
            som += beschrijving[letter][1]
    return som

def enkel_rechte_lijnen(locatie, beschrijving):
    set_totaal = set()
    # open de file
    with open(locatie, 'r') as file:
        for line in file:
            # na elke line gelezen te hebben, verwijder de '\n' vanachteraan het woord als er nog in zitten
            if line[-1] == '\n':
                line = line[:-1]
                # als kromme lijnen 0 is en rechte lijnen niet, voeg het toe aan de lege set
            if aantal_kromme_lijnen(line, beschrijving) == 0 and aantal_rechte_lijnen(line, beschrijving) != 0:
                set_totaal.add(line)
    return set_totaal
# zo goed als hetzelfe als hierboven
def enkel_kromme_lijnen(locatie, beschrijving):
    set_totaal = set()
    with open(locatie, 'r') as file:
        for line in file:
            if line[-1] == '\n':
                line = line[:-1]
            if aantal_kromme_lijnen(line, beschrijving) != 0 and aantal_rechte_lijnen(line, beschrijving) == 0:
                set_totaal.add(line)
    return set_totaal

def gebalanceerde_lijnen(locatie, beschrijving):
    set_totaal = set()
    #open de file
    with open(locatie, 'r') as file:
        for line in file:
            # na elke line gelezen te hebben, verwijder de '\n'
            if line[-1] == '\n':
                line = line[:-1]
                #als het aantal kromme lijnen gelijk zijn aan het aantal rechte lijnen voeg ze toe aan de lege set
            if aantal_kromme_lijnen(line, beschrijving) == aantal_rechte_lijnen(line, beschrijving):
                set_totaal.add(line)
    return set_totaal",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( comment ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ( string ) ) ) ) ( comment ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( integer ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( comparison_operator ( subscript ( identifier ) ( unary_operator ( integer ) ) ) ( string ( escape_sequence ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ( comment ) ) ) ( if_statement ( boolean_operator ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( subscript ( identifier ) ( unary_operator ( integer ) ) ) ( string ( escape_sequence ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ) ) ( if_statement ( boolean_operator ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( comparison_operator ( subscript ( identifier ) ( unary_operator ( integer ) ) ) ( string ( escape_sequence ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ( comment ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),110,"{""filename"":""n/a/geometrische-letters.py"",""fullName"":""n/a"",""id"":""12947"",""status"":""correct"",""submissionID"":""6749942"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:54:08.000Z"",""labels"":""fyss""}"
169,../exam-folder/Arne Dhont/geometrische-letters.py,"def lees_lettertype(locatie):
    locatie = open(locatie)
    f = {}
    for regel in locatie:
        a = regel.split(' ')
        f[a[0]] = (int(a[1]), int(a[2][:-1]))
    locatie.close()
    return f

def aantal_rechte_lijnen(woord, lettertype):
    som = 0
    for i in woord:
        if i in lettertype.keys():
            som += lettertype[i][0]
    return som

def aantal_kromme_lijnen(woord, lettertype):
    som = 0
    for i in woord:
        if i in lettertype.keys():
            som += lettertype[i][1]
    return som

def enkel_rechte_lijnen(locatie, lettertype):
    locatie = open(locatie)
    verzameling = set()
    lengte = 0
    for regel in locatie:
        woord = regel[:-1]
        for i in woord:
            if i in lettertype.keys():
                if lettertype[i][1] == 0:
                    lengte += 1
            elif not i.isalpha():
                lengte += 1
        if lengte == len(woord):
            verzameling.add(woord)
        lengte = 0
    return verzameling

def enkel_kromme_lijnen(locatie, lettertype):
    verzameling = set()
    lengte = 0
    locatie = open(locatie)
    for regel in locatie:
        woord = regel[:-1]
        for i in woord:
            if i in lettertype.keys():
                if lettertype[i][0] == 0:
                    lengte += 1
            elif not i.isalpha():
                lengte += 1
        if lengte == len(woord):
            verzameling.add(woord)
        lengte = 0
    locatie.close()
    return verzameling

def gebalanceerde_lijnen(locatie, lettertype):
    verzameling = set()
    locatie = open(locatie)
    for regel in locatie:
        woord = regel[:-1]
        if aantal_kromme_lijnen(woord, lettertype) == aantal_rechte_lijnen(woord, lettertype):
            verzameling.add(woord)
    return verzameling",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( subscript ( identifier ) ( integer ) ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( block ( if_statement ( comparison_operator ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ( integer ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( integer ) ) ) ) ) ) ( elif_clause ( not_operator ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( integer ) ) ) ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( block ( if_statement ( comparison_operator ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ( integer ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( integer ) ) ) ) ) ) ( elif_clause ( not_operator ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( integer ) ) ) ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),120,"{""filename"":""Arne Dhont/geometrische-letters.py"",""fullName"":""Arne Dhont"",""id"":""12955"",""status"":""correct"",""submissionID"":""6748860"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:27:03.000Z"",""labels"":""fyss""}"
170,../exam-folder/Fedra Moeykens/geometrische-letters.py,"def lees_lettertype(bestand):   #definiren van verzameling koppels rechte en schuine strepen
    invoer = open(bestand, 'r') #bestand lezen
    verzameling = {}
    
    for line in invoer:
        lijst = line.split() #regel opsplitsen in lijst zodanig dat de waarden gesplitst worden
        verzameling[lijst[0]]= (int(lijst[1]), int(lijst[2])) #eerste letter waarde geven voor schuine en rechte strepen
        
    return verzameling #teruggeven van verzameling

def aantal_rechte_lijnen(woord, lettertype): #definiren hoeveel rechte lijnen in een woord zitten
    som_rechte = 0 
    
    for letter in woord: #for-loop waardoor het aantal rechte lijnen van elke letter van het woord telkens wordt opgeteld
        if letter.isalpha():
            rechte, kromme = lettertype[letter]
            som_rechte += rechte 
            
    return som_rechte

def aantal_kromme_lijnen(woord, lettertype): #definiren hoeveel kromme lijnen in een woord zitten
    som_kromme = 0
    
    for letter in woord: #for-loop waardoor het aantal kromme lijnen van elke letter van het woord telkens wordt opgeteld
        if letter.isalpha():
            rechte, kromme = lettertype[letter]
            som_kromme += kromme
            
    return som_kromme #som kromme lijnen teruggeven
    
def enkel_rechte_lijnen(bestand, lettertype): #nakijken hoeveel woorden in een bestand enkel met rechte lijnen worden geschreven
    invoer = open(bestand, 'r')
    verzameling = set()
    
    for woord in invoer: #for-loop waardoor elk woord in het bestand wordt nagekeken op het bevatten van kromme lijnen
        woord = woord.replace('\n','')
        if aantal_kromme_lijnen(woord,lettertype) == 0: #indien het woord geen kromme lijnen bevat wordt deze toegevoegd aan de                                             set
            
            verzameling.add(woord)
            
    return verzameling
    
def enkel_kromme_lijnen(bestand, lettertype): #nakijken hoeveel woorden in een bestand enkel met kromme lijnen worden geschreven
    invoer = open(bestand, 'r')
    verzameling = set()
    
    for woord in invoer: #for-loop waardoor elk woord in het bestand wordt nagekeken op het bevatten van rechte lijnen
        woord = woord.replace('\n','')
        
        if aantal_rechte_lijnen(woord,lettertype) == 0:
            
            verzameling.add(woord) #indien het woord geen rechtelijnen bevat wordt deze toegevoegd aan de                                             set
    return verzameling
    
def gebalanceerde_lijnen(bestand, lettertype): #definiren van functie waarbij wordt nagekeken hoeveel woorden evenveel kromme                                              als rechte lijnen bevatten 
    invoer = open(bestand, 'r')
    verzameling = set()
    
    for woord in invoer:
        woord = woord.replace('\n','')
        
        if aantal_rechte_lijnen(woord,lettertype) == aantal_kromme_lijnen(woord,lettertype): #nakijken of het woord evenveel                                            kromme als rechte lijnen bevat
            
            verzameling.add(woord)
    return verzameling #teruggeven van set woorden die evenveel kromme als rechte lijnen bevatten",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( comment ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ( comment ) ( return_statement ( identifier ) ) ) ) ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( subscript ( identifier ) ( identifier ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( pattern_list ( identifier ) ( identifier ) ) ( subscript ( identifier ) ( identifier ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ( string ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ( string ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ( string ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( comment ) ),100,"{""filename"":""Fedra Moeykens/geometrische-letters.py"",""fullName"":""Fedra Moeykens"",""id"":""12956"",""status"":""correct"",""submissionID"":""6750619"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:13:31.000Z"",""labels"":""fyss""}"
171,../exam-folder/Ahmed Karakai/geometrische-letters.py,"def read_font(file_name):
    # open the file
    with open(file_name, 'r') as text_file:
        # for loop to analyze each line
        dictionary = {}
        for line in text_file.readlines():
            line = line.strip('\n').split()
            # add elements to dictionary
            dictionary[line[0]] = tuple((int(line[1]), int(line[2])))
        return dictionary

def count_straight_lines(word, font):
    total_straight = 0
    # for loop to analyze each letter of the word
    for index, letter in enumerate(word):
        check = letter
        if check.isalpha():
            total_straight += font[letter][0]
    return total_straight

def count_curved_lines(word, font):
    # same code as the above function, but index is 1
    total_curved = 0
    # for loop to analyze each letter of the word
    for index, letter in enumerate(word):
        check = letter
        if check.isalpha():
            total_curved += font[letter][1]
    return total_curved

def straight_lines_only(text_file, font):
    # create an empty set for the final result
    res = set()
    # open text file
    with open(text_file, 'r') as words:
        # loop every line of the file
        for line in words.readlines():
            line = line.strip('\n')
            # check how many curved line the word has
            nCurved = count_curved_lines(line, font)
            # if the word has zero curved letters, add word to set
            if nCurved == 0:
                res.add(line)
    return res

def curved_lines_only(text_file, font):
    # same as above function, but we find words with straight letters == 0
    # create an empty set for the final result
    res = set()
    # open text file
    with open(text_file, 'r') as words:
        # loop every line of the file
        for line in words.readlines():
            line = line.strip('\n')
            # check how many curved line the word has
            nStraight = count_straight_lines(line, font)
            # if the word has zero curved letters, add word to set
            if nStraight == 0:
                res.add(line)
    return res

def balanced_lines(text_file, font):
    # it is a fusion between the two previous functions
    
    # create an empty set for the final result
    res = set()
    # open text file
    with open(text_file, 'r') as words:
        # loop every line of the file
        for line in words.readlines():
            line = line.strip('\n')
            # check how many curved line the word has
            nStraight = count_straight_lines(line, font)
            nCurved = count_curved_lines(line, font)
            # if the word has zero curved letters, add word to set
            if nStraight == nCurved:
                res.add(line)
    return res
    

if __name__ == '__main__':
    import doctest
    doctest.testmod()
",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( comment ) ( block ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ( argument_list ) ) ) ) ( comment ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( call ( identifier ) ( argument_list ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( pattern_list ( identifier ) ( identifier ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( identifier ) ) ) ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( pattern_list ( identifier ) ( identifier ) ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( identifier ) ) ) ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( comment ) ( block ( for_statement ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( comment ) ( block ( for_statement ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( identifier ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( comment ) ( block ( for_statement ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),131,"{""filename"":""Ahmed Karakai/geometrische-letters.py"",""fullName"":""Ahmed Karakai"",""id"":""12946"",""status"":""correct"",""submissionID"":""6748166"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:09:52.000Z"",""labels"":""fyss""}"
172,../exam-folder/Robbe Bilteryst/geometrische-letters.py,"def lees_lettertype(bestand):
    tekstBestand = open(bestand, 'r')
    inhoudBestand = tekstBestand.readlines()
    tekstBestand.close()
    lettertype = {}
    for lijn in inhoudBestand:
        letter = lijn.replace('\n', '').split(' ')
        lettertype.update({letter[0]: (int(letter[1]), int(letter[2]))})
    return lettertype

def aantal_rechte_lijnen(woord, lettertype):
    aantal = 0
    for letter in woord:
        if lettertype.get(letter):
            aantal += lettertype.get(letter)[0]
    return aantal

def aantal_kromme_lijnen(woord, lettertype):
    aantal = 0
    for letter in woord:
        if lettertype.get(letter):
            aantal += lettertype.get(letter)[1]
    return aantal

def enkel_rechte_lijnen(woordenboek, lettertype):
    tekstBestand = open(woordenboek, 'r')
    inhoudBestand = tekstBestand.readlines()
    tekstBestand.close()
    woordenlijst = set()
    for lijn in inhoudBestand:
        woord = lijn.replace('\n', '')
        if aantal_kromme_lijnen(woord, lettertype) == 0:
            woordenlijst.add(woord)
    return woordenlijst

def enkel_kromme_lijnen(woordenboek, lettertype):
    tekstBestand = open(woordenboek, 'r')
    inhoudBestand = tekstBestand.readlines()
    tekstBestand.close()
    woordenlijst = set()
    for lijn in inhoudBestand:
        woord = lijn.replace('\n', '')
        if aantal_rechte_lijnen(woord, lettertype) == 0:
            woordenlijst.add(woord)
    return woordenlijst

def gebalanceerde_lijnen(woordenboek, lettertype):
    tekstBestand = open(woordenboek, 'r')
    inhoudBestand = tekstBestand.readlines()
    tekstBestand.close()
    woordenlijst = set()
    for lijn in inhoudBestand:
        woord = lijn.replace('\n', '')
        if aantal_rechte_lijnen(woord, lettertype) == aantal_kromme_lijnen(woord, lettertype):
            woordenlijst.add(woord)
    return woordenlijst",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ( string ) ) ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( dictionary ( pair ( subscript ( identifier ) ( integer ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ( string ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ( string ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ( string ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),105,"{""filename"":""Robbe Bilteryst/geometrische-letters.py"",""fullName"":""Robbe Bilteryst"",""id"":""12967"",""status"":""correct"",""submissionID"":""6749317"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:37:46.000Z"",""labels"":""fyss""}"
173,../exam-folder/Jef Philipp/geometrische-letters.py,"def lees_lettertype(bestand):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> lettertype['E']
    (4, 0)
    >>> lettertype['R']
    (2, 1)
    >>> lettertype['G']
    (1, 1)
    >>> lettertype['O']
    (0, 1)
    """"""
    #Bestand lezen en dictionary aanmaken
    invoer = open(bestand, 'r')
    lettertype = dict()
    
    #We overlopen elke regel van het bestand en zetten deze om in een lijst waaruit we dan makkelijk de gezochte waarden kunnen halen
    for regel in invoer:
        regel = regel.rstrip('\n').split(' ')
        lettertype[regel[0]] = (int(regel[1]), int(regel[2]))
    return lettertype


def aantal_rechte_lijnen(woord, lettertype):
    """"""
    >>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
    21
    """"""
    #Simpele som die alle letters uit het woord afgaat en daarbij de rechte lijnen optelt
    return sum([lettertype[letter][0] for letter in woord if letter.isalpha()])

def aantal_kromme_lijnen(woord, lettertype):
    """"""
    >>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
    4
    """"""
    #Zelfde als vorige functie, maar nu met kromme lijnen
    return sum([lettertype[letter][1] for letter in woord if letter.isalpha()])

def enkel_rechte_lijnen(bestand, lettertype):
    """"""
    >>> enkel_rechte_lijnen('woordenboek.txt', lettertype)
    {'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
    """"""
    #Bestand openen
    invoer = open(bestand, 'r')
    
    #Controleren of het aantal kromme lijnen van een woord gelijk is aan nul
    return {woord.rstrip('\n') for woord in invoer if aantal_kromme_lijnen(woord.rstrip(), lettertype) == 0}

def enkel_kromme_lijnen(bestand, lettertype):
    """"""
    >>> enkel_kromme_lijnen('woordenboek.txt', lettertype)
    {'COCCUS', 'COUSCOUS'}
    """"""
    #Zelfde principe maar nu moeten aantal rechte lijnen gelijk zijn aan nul
    invoer = open(bestand, 'r')
    return {woord.rstrip('\n') for woord in invoer if aantal_rechte_lijnen(woord.rstrip(), lettertype) == 0}

def gebalanceerde_lijnen(bestand, lettertype):
    """"""
    >>> gebalanceerde_lijnen('woordenboek.txt', lettertype)
    {'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}
    """"""
    
    #Zelfde principe, maar aantal rechte lijnen moet gelijk zijn aan het aantal kromme lijnen
    invoer = open(bestand, 'r')
    return {woord.rstrip('\n') for woord in invoer if aantal_rechte_lijnen(woord.rstrip(), lettertype) == aantal_kromme_lijnen(woord.rstrip(), lettertype)}",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( return_statement ( call ( identifier ) ( argument_list ( list_comprehension ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( return_statement ( call ( identifier ) ( argument_list ( list_comprehension ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( comment ) ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( comparison_operator ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ) ( integer ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( comparison_operator ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ) ( integer ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( comparison_operator ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ) ) ) ) ) ) ) ),89,"{""filename"":""Jef Philipp/geometrische-letters.py"",""fullName"":""Jef Philipp"",""id"":""12972"",""status"":""correct"",""submissionID"":""6750161"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:00:21.000Z"",""labels"":""fyss""}"
174,../exam-folder/Chloe De Noble/geometrische-letters.py,"def lees_lettertype(locatie):
    uitvoer = dict()
    invoer = open(locatie)
    data = (invoer.readline()).strip('\n')",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( parenthesized_expression ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ) ) ),7,"{""filename"":""Chloe De Noble/geometrische-letters.py"",""fullName"":""Chloe De Noble"",""id"":""12094"",""status"":""runtime error"",""submissionID"":""6749499"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:41:39.000Z"",""labels"":""bcbt""}"
175,../exam-folder/Kimberly Demeestere/geometrische-letters.py,"def lees_lettertype(bestand):
    bestand = open(bestand)  # bestand openen
    lettertype = dict()  # dictionairy opstellen
    for regel in bestand:   # regels in bestand overlopen
        regel = regel.strip()   # onnodige karakters aan uiteinden string verwijderen
        regel = regel.split(' ')    # string splitsen op spatie in reeks met 3 elementen
        lettertype[regel[0]] = (int(regel[1]), int(regel[2]))   # tuple toevoegen aan dictionairy
    return lettertype


def aantal_rechte_lijnen(woord, lettertype):
    aantal = 0  # teller initialiseren
    for letter in woord:    # elke letter in woord overlopen
        if letter in lettertype:    # enkel indien letter in lettertype (andere karakters negeren)
            aantal += lettertype[letter][0]     # rechte lijnen zijn aantal op plaats 0 in tuple
    return aantal


def aantal_kromme_lijnen(woord, lettertype):    # idem vorige functie
    aantal = 0
    for letter in woord:
        if letter in lettertype:
            aantal += lettertype[letter][1]  # rechte lijnen zijn aantal op plaats 1  in tuple
    return aantal


def enkel_rechte_lijnen(bestand, lettertype):
    bestand = open(bestand)  # bestand openen
    rechte_woorden = set()  # set initialiseren
    for woord in bestand:   # elk woord in bestand overlopen
        woord = woord.strip()   # onnodige karakters aan uieinden verwijderen
        aantal_recht = 0   # aantal letters met enkel rechte lijnen
        for letter in woord:
            if letter not in lettertype:    # andere karakters negeren
                aantal_recht += 1
            elif lettertype[letter][1] == 0:    # aantal komme lijnen moet 0 zijn om enkel uit rechte lijnen te bestaan
                aantal_recht += 1
        if aantal_recht == len(woord):  # indien aantal karakters in woord = aantal karakters met enkel rechte lijnen
            rechte_woorden.add(woord)   # woord toevoegen aan set
    return rechte_woorden


def enkel_kromme_lijnen(bestand, lettertype):   # zelfde redenering als vorige functie
    bestand = open(bestand)
    kromme_woorden = set()
    for woord in bestand:
        woord = woord.strip()
        aantal_krom = 0
        for letter in woord:
            if letter not in lettertype:
                aantal_krom += 1
            elif lettertype[letter][0] == 0:
                aantal_krom += 1
        if aantal_krom == len(woord):
            kromme_woorden.add(woord)
    return kromme_woorden


def gebalanceerde_lijnen(bestand, lettertype):
    bestand = open(bestand)  # bestand openen
    gebalanceerde_woorden = set()   # set initialiseren
    for woord in bestand:   # elk woord in bestand overlopen
        woord = woord.strip()   # onnodige karakters verwijderen
        # aantallen bepalen met vorige functies
        aantal_krom = aantal_kromme_lijnen(woord, lettertype)
        aantal_recht = aantal_rechte_lijnen(woord, lettertype)
        if aantal_recht == aantal_krom:  # indien evenveel recht als krom, woord toevoegen aan set
            gebalanceerde_woorden.add(woord)
    return gebalanceerde_woorden
",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ( comment ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( integer ) ) ) ) ( elif_clause ( comparison_operator ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ( integer ) ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( integer ) ) ) ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( integer ) ) ) ) ( elif_clause ( comparison_operator ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ( integer ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( integer ) ) ) ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( comment ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),129,"{""filename"":""Kimberly Demeestere/geometrische-letters.py"",""fullName"":""Kimberly Demeestere"",""id"":""12986"",""status"":""correct"",""submissionID"":""6750234"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:02:13.000Z"",""labels"":""geol""}"
176,../exam-folder/Jasper Demaertelaere/geometrische-letters.py,"def lees_lettertype(lettertype):
    with open(lettertype) as beschrijving:
        dicty = {}
        for line in beschrijving:
            line = line.split()
            dicty[line[0]] = (int(line[1]), int(line[2]))
    return dicty


def aantal_rechte_lijnen(woord, lettertype):
    aantal = 0
    for letter in woord:
        if letter.isalpha():
            aantal += lettertype[letter][0]
    return aantal


def aantal_kromme_lijnen(woord, lettertype):
    aantal = 0
    for letter in woord:
        if letter.isalpha():
            aantal += lettertype[letter][1]
    return aantal


def enkel_rechte_lijnen(woorden, lettertype):
    return {woord.rstrip('\n') for woord in open(woorden) if aantal_kromme_lijnen(woord, lettertype) == 0}


def enkel_kromme_lijnen(woorden, lettertype):
    return {woord.rstrip('\n') for woord in open(woorden) if aantal_rechte_lijnen(woord, lettertype) == 0}


def gebalanceerde_lijnen(woorden, lettertype):
    return {woord.rstrip('\n') for woord in open(woorden) if aantal_rechte_lijnen(woord, lettertype) == aantal_kromme_lijnen(woord, lettertype)}",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( for_in_clause ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ( if_clause ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( for_in_clause ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ( if_clause ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( for_in_clause ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ( if_clause ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ) ) ) ) ),69,"{""filename"":""Jasper Demaertelaere/geometrische-letters.py"",""fullName"":""Jasper Demaertelaere"",""id"":""12995"",""status"":""correct"",""submissionID"":""6750122"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:59:09.000Z"",""labels"":""fyss""}"
177,../exam-folder/Jitse Van Nueten/geometrische-letters.py,"def lees_lettertype(locatie):
    invoer = open(locatie)
    #het bestand in de locatie wordt gelezen
    bestand = invoer.readlines()
    d = dict()
    #per regel in het bestand splitsen we de regel op in drie delen
    for regel in bestand:
        regel = regel.split(' ')
        #het eerste deel is de letter, het tweede is het aantal rechte lijnen en het derde het aantal kromme lijnen
        #we zetten deze in een dictionary met deel twee en drie in een tuple
        d[regel[0]] = (int(regel[1]), int(regel[2][:-1]))
    return d


def aantal_rechte_lijnen(woord, lettertype):
    som = 0
    #per letter in het woord bepalen we het aantal rechte lijnen
    for letter in woord:
        if letter.isalpha():
            #uit de dictionary halen we het eerste element van de tuple om te sommeren
            a = lettertype[letter]
            som += a[0]
    return som


def aantal_kromme_lijnen(woord, lettertype):
    som = 0
    #gelijk aan bovenstaande functie, met kromme lijnen
    for letter in woord:
        if letter.isalpha():
            a = lettertype[letter]
            som += a[1]
    return som


def enkel_rechte_lijnen(locatie, lettertype):
    invoer = open(locatie)
    bestand = invoer.readlines()
    woorden = set()
    #per regel in het bestand staat er het woord waarvoor we nakijken of er geen kromme lijnen in staan
    for regel in bestand:
        if aantal_kromme_lijnen(regel, lettertype) == 0:
            #indien er geen kromme lijnen zijn kan deze toegevoegd worden aan de set
            woorden.add(regel[:-1])
    return woorden


def enkel_kromme_lijnen(locatie, lettertype):
    invoer = open(locatie)
    # gelijk aan bovenstaande functie, met kromme lijnen
    bestand = invoer.readlines()
    woorden = set()
    for regel in bestand:
        if aantal_rechte_lijnen(regel, lettertype) == 0:
            woorden.add(regel[:-1])
    return woorden


def gebalanceerde_lijnen(locatie, lettertype):
    invoer = open(locatie)
    bestand = invoer.readlines()
    woorden = set()
    # per regel in het bestand staat er het woord waarvoor we nakijken of het aantal kromme en rechte lijnen gelijk zijn
    for regel in bestand:
        if aantal_rechte_lijnen(regel, lettertype) == aantal_kromme_lijnen(regel,lettertype):
            # indien het aantal rechte en kromme lijnen gelijk zijn kan deze toegevoegd worden aan de set
            woorden.add(regel[:-1])
    return woorden",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( comment ) ( comment ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( subscript ( identifier ) ( integer ) ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( identifier ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( identifier ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),112,"{""filename"":""Jitse Van Nueten/geometrische-letters.py"",""fullName"":""Jitse Van Nueten"",""id"":""12997"",""status"":""correct"",""submissionID"":""6749166"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:34:30.000Z"",""labels"":""fyss""}"
178,../exam-folder/Catharina Van Laethem/geometrische-letters.py,"def lees_lettertype(locatie):
    reader = open(locatie, ""r"")
    lines = filter(None, (line.rstrip() for line in reader))
    d = dict()
    for lijn in lines:
        lijn = lijn.replace("" "", """")
        d[lijn[0]] = (int(lijn[1]), int(lijn[2]))
    return d
def aantal_rechte_lijnen(woord, lettertype):
    som = 0
    for i in woord:
        if i in lettertype.keys():
            waarde = lettertype.get(i)
            rechte_lijn = waarde[0]
            som += rechte_lijn
    return som
def aantal_kromme_lijnen(woord, lettertype):
    som = 0
    for i in woord:
        if i in lettertype.keys():
            waarde = lettertype.get(i)
            rechte_lijn = waarde[1]
            som += rechte_lijn
    return som
def enkel_rechte_lijnen(locatie, lettertype):
    reader = open(locatie, ""r"")
    lines = filter(None, (lijn.rstrip() for lijn in reader))
    resultaat = set()
    for lijn in lines:
        if aantal_kromme_lijnen(lijn, lettertype) == 0:
            resultaat.add(lijn)
    return resultaat
def enkel_kromme_lijnen(locatie, lettertype):
    reader = open(locatie, ""r"")
    lines = filter(None, (lijn.rstrip() for lijn in reader))
    resultaat = set()
    for lijn in lines:
        if aantal_rechte_lijnen(lijn, lettertype) == 0:
            resultaat.add(lijn)
    return resultaat
def gebalanceerde_lijnen(locatie, lettertype):
    reader = open(locatie, ""r"")
    lines = filter(None, (lijn.rstrip() for lijn in reader))
    resultaat = set()
    for lijn in lines:
        if aantal_rechte_lijnen(lijn, lettertype) == aantal_kromme_lijnen(lijn, lettertype):
            resultaat.add(lijn)
    return resultaat",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( none ) ( generator_expression ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( for_in_clause ( identifier ) ( identifier ) ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ) ( expression_statement ( augmented_assignment ( identifier ) ( identifier ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( none ) ( generator_expression ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( for_in_clause ( identifier ) ( identifier ) ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( none ) ( generator_expression ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( for_in_clause ( identifier ) ( identifier ) ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( none ) ( generator_expression ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( for_in_clause ( identifier ) ( identifier ) ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),98,"{""filename"":""Catharina Van Laethem/geometrische-letters.py"",""fullName"":""Catharina Van Laethem"",""id"":""11841"",""status"":""correct"",""submissionID"":""6748678"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:22:39.000Z"",""labels"":""bcbt""}"
179,../exam-folder/Ian Van Lierde/geometrische-letters.py,"def lees_lettertype(bestand):
    invoer = open(bestand, 'r')
    dict = {}
    regels = invoer.readlines()
    for regel in regels:
        #karakters uit strings halen en omzetten
        dict[regel[0]] = (int(regel[2]), int(regel[4]))
    invoer.close()
    return dict
def aantal_rechte_lijnen(woord, lettertype):
    aantal_rechte_lijnen = 0
    for letter in woord:
        #de eerste waarde in de tuple is die van rechte lijnen
        aantal_rechte_lijnen += lettertype[letter][0]
    return aantal_rechte_lijnen
def aantal_kromme_lijnen(woord, lettertype):
    aantal_kromme_lijnen = 0
    for letter in woord:
        #de tweede waarde in de tuple is die van kromme lijnen
        aantal_kromme_lijnen += lettertype[letter][1]
    return aantal_kromme_lijnen
def enkel_rechte_lijnen(bestand, lettertype):
    invoer = open(bestand, 'r')
    enkel_rechte_lijnen = set()
    for woord in invoer.read().split('\n'):
        #als het aantal kromme lijnen 0 is dan zijn er enkel rechte lijnen
        if aantal_kromme_lijnen(woord, lettertype) == 0:
            enkel_rechte_lijnen.add(woord)
    invoer.close()
    return enkel_rechte_lijnen",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( call ( attribute ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( comment ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ( return_statement ( identifier ) ) ) ) ),48,"{""filename"":""Ian Van Lierde/geometrische-letters.py"",""fullName"":""Ian Van Lierde"",""id"":""13030"",""status"":""runtime error"",""submissionID"":""6750650"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:14:35.000Z"",""labels"":""geol""}"
180,../exam-folder/Emiel Botterman/geometrische-letters.py,"""""""
>>> lettertype = lees_lettertype('lettertype.txt')
>>> lettertype['E']
(4, 0)
>>> lettertype['R']
(2, 1)
>>> lettertype['G']
(1, 1)
>>> lettertype['O']
(0, 1)
>>> aantal_rechte_lijnen('ERGONOMIE', lettertype)
21
>>> aantal_kromme_lijnen('ERGONOMIE', lettertype)
4
>>> enkel_rechte_lijnen('woordenboek.txt', lettertype)
{'LAVEMENT', 'INTIMITEITEN', 'ZEVENENHALF', 'VETZAK', 'ZAKENMAN'}
>>> enkel_kromme_lijnen('woordenboek.txt', lettertype)
{'COCCUS', 'COUSCOUS'}
>>> gebalanceerde_lijnen('woordenboek.txt', lettertype)
{'SCULPTUUR', 'STADSBOS', 'BOORPROCES', 'SUDOKU'}
""""""

def lees_lettertype(locatie):
    #open het tekstbestand
    info = open(locatie, 'r')
    #maak een hulp dict aan waar de waarden worden in gestoken
    dict = {}

    for regel in info:

        regel.split(' ')
        dict[regel[0]] = (int(regel[2]), int(regel[4])) #voeg de getallen toe

    return dict

def aantal_rechte_lijnen(woord, letterype):
    recht = 0
    for letter in woord:
        if letter.isalpha():
            recht += letterype[letter][0]

    return recht

def aantal_kromme_lijnen(woord, lettertype):
    gebogen = 0
    for letter in woord:
        if letter.isalpha():
            gebogen += lettertype[letter][1]

    return gebogen

def enkel_rechte_lijnen(locatie, lettertype):
    info = open(locatie)

    verzameling = set()

    # enkel recht wilt zeggen geen gebogen lijnen
    for woord in info:
        woord = woord[:-1]  #voor de \n weg te krijgen
        if aantal_kromme_lijnen(woord, lettertype) == 0:
            verzameling.add(woord)

    return verzameling

def enkel_kromme_lijnen(locatie, lettertype):
    info = open(locatie)

    verzameling = set()

    # enkel krom wilt zeggen geen rechte lijnen
    for woord in info:
        woord = woord[:-1]  # voor de \n weg te krijgen
        if aantal_rechte_lijnen(woord, lettertype) == 0:
            verzameling.add(woord)

    return verzameling

def gebalanceerde_lijnen(locatie, lettertype):
    info = open(locatie)

    verzameling = set()

    # even veel krom als recht
    for woord in info:
        woord = woord[:-1]  # voor de \n weg te krijgen
        if aantal_rechte_lijnen(woord, lettertype) == aantal_kromme_lijnen(woord, lettertype):
            verzameling.add(woord)

    return verzameling





if __name__ == '__main__':
    import doctest

    doctest.testmod()
",( module ( expression_statement ( string ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( comment ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ( comment ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( comment ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ( comment ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),91,"{""filename"":""Emiel Botterman/geometrische-letters.py"",""fullName"":""Emiel Botterman"",""id"":""11863"",""status"":""correct"",""submissionID"":""6748102"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:07:46.000Z"",""labels"":""fyss""}"
181,../exam-folder/Robbe Van de Keere/geometrische-letters.py,"def lees_lettertype(file):
    txt = open(file, ""r"")
    out_dict = {}
    for line in txt:
        attributes = line.split()
        out_dict[attributes[0]] = (int(attributes[1]), int(attributes[2]))
    return out_dict


def aantal_rechte_lijnen(woord_str, lettertype_dict):
    count = 0
    for letter in woord_str:
        if letter.isalpha():  # het zijn dictionaries die enkel letters bevatten, dus is .alpha() gemakkelijker
            count += lettertype_dict[letter][0]  # dan voor ieder karakter zoeken of het in de dict zit
    return count


def aantal_kromme_lijnen(woord_str, lettertype_dict):
    count = 0
    for letter in woord_str:
        if letter.isalpha():
            count += lettertype_dict[letter][1]
    return count


def enkel_rechte_lijnen(woorden_file, lettertype_dict):
    out_set = set()
    woorden_txt = open(woorden_file, ""r"")
    for woord in woorden_txt:
        if not aantal_kromme_lijnen(woord, lettertype_dict):  # enkel rechte of dus 0 kromme lijnen
            out_set.add(woord.strip())  # carriage return wegdoen (mag achteraf want wordt niet geteld door functie)
    return out_set


def enkel_kromme_lijnen(woorden_file, lettertype_dict):
    out_set = set()
    woorden_txt = open(woorden_file, ""r"")
    for woord in woorden_txt:
        if not aantal_rechte_lijnen(woord, lettertype_dict):
            out_set.add(woord.strip())
    return out_set


def gebalanceerde_lijnen(woorden_file, lettertype_dict):
    out_set = set()
    woorden_txt = open(woorden_file, ""r"")
    for woord in woorden_txt:
        if aantal_rechte_lijnen(woord, lettertype_dict) == aantal_kromme_lijnen(woord, lettertype_dict):
            out_set.add(woord.strip())
    return out_set
",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( not_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( comment ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( not_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),92,"{""filename"":""Robbe Van de Keere/geometrische-letters.py"",""fullName"":""Robbe Van de Keere"",""id"":""13041"",""status"":""correct"",""submissionID"":""6749950"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:54:24.000Z"",""labels"":""fyss""}"
182,../exam-folder/Bert Wallaert/geometrische-letters.py,"import string


def lees_lettertype(locatie):
    """"""
    >>> lettertype = lees_lettertype('lettertype.txt')
    >>> lettertype['E']
    (4, 0)
    >>> lettertype['R']
    (2, 1)
    """"""
    dikkie = {}
    with open(locatie, 'r') as elementen:
        for lijn in elementen.readlines():
            # Op [0] staat de letter, op [2] staat aantal recht en op [4] staat aantal krom
            dikkie[lijn[0]] = (int(lijn[2]), int(lijn[4]))
    return dikkie


def aantal_rechte_lijnen(woord, lettertype):
    """"""
    >>> lettertyp = lees_lettertype('lettertype.txt')
    >>> aantal_rechte_lijnen('ERGONOMIE', lettertyp)
    21
    """"""
    aantal = 0
    for letter in woord:
        if letter in string.ascii_letters:
            aantal += lettertype[letter][0]
    return aantal


def aantal_kromme_lijnen(woord, lettertype):
    aantal = 0
    for letter in woord:
        if letter in string.ascii_letters:
            aantal += lettertype[letter][1]
    return aantal


def enkel_rechte_lijnen(locatie, lettertype):
    seth = set()
    with open(locatie, 'r') as woorden:
        for woord in woorden.readlines():
            woord = woord.strip(""\n"")
            krom = aantal_kromme_lijnen(woord, lettertype)
            # Als er een kromme lijn in zit, bestaat het niet alleen uit rechte lijnen en mag het er niet bij
            # Het mag er alleen bij als krom = 0
            if not krom:
                seth.add(woord)
    return seth


def enkel_kromme_lijnen(locatie, lettertype):
    # Dit kan ook door het verschil tussen alle woorden en Enkel_rechte_lijnen
    seth = set()
    with open(locatie, 'r') as woorden:
        for woord in woorden.readlines():
            woord = woord.strip(""\n"")
            recht = aantal_rechte_lijnen(woord, lettertype)
            # Als er een rechte lijn in zit, bestaat het niet alleen uit kromme lijnen en mag het er niet bij
            # Het mag er alleen bij als recht = 0
            if not recht:
                seth.add(woord)
    return seth


def gebalanceerde_lijnen(locatie, lettertype):
    seth = set()
    with open(locatie, 'r') as woorden:
        for woord in woorden.readlines():
            woord = woord.strip(""\n"")
            if aantal_rechte_lijnen(woord, lettertype) == aantal_kromme_lijnen(woord, lettertype):
                seth.add(woord)
    return seth


if __name__ == '__main__':
    import doctest
    doctest.testmod()
",( module ( import_statement ( dotted_name ( identifier ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( comment ) ( block ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( attribute ( identifier ) ( identifier ) ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( attribute ( identifier ) ( identifier ) ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( comment ) ( comment ) ( if_statement ( not_operator ( identifier ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( comment ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ) ( comment ) ( comment ) ( if_statement ( not_operator ( identifier ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),105,"{""filename"":""Bert Wallaert/geometrische-letters.py"",""fullName"":""Bert Wallaert"",""id"":""13097"",""status"":""correct"",""submissionID"":""6749351"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T14:38:29.000Z"",""labels"":""fyss""}"
183,../exam-folder/Charles Deberlanger/geometrische-letters.py,"def read_font(location):
    font = open(location)
    dictio = {}
    for regel in font:  # Because of the predetermined structure of the txt, we can assume that this will always work
        dictio[regel[0]] = (int(regel[2]), int(regel[4]))
    return dictio

def count_straight_lines(word, font):
    count = 0
    for char in word:
        if char.isalpha():  # Make sure we only check for characters
            count += font[char][0]  # Take the first value of the tuple
    return count

def count_curved_lines(word, font):
    count = 0
    for char in word:
        if char.isalpha():  # Make sure we only check for characters
            count += font[char][1]  # Take the second value of the tuple
    return count

def straight_lines_only(location, font):
    awnset = set()
    words = open(location)
    for word in words:  # Only add the word if the condition is met
        if count_curved_lines(word, font) == 0:
            awnset.add(word[:-1])   # Remove the final ""\n""
    return awnset

def curved_lines_only(location, font):
    awnset = set()
    words = open(location)
    for word in words:  # Only add the word if the condition is met
        if count_straight_lines(word, font) == 0:
            awnset.add(word[:-1])   # Remove the final ""\n""
    return awnset

def balanced_lines(location, font):
    awnset = set()
    words = open(location)
    for word in words:  # Repeat the behaviour as before, but with another condition
        if count_straight_lines(word, font) == count_curved_lines(word, font):
            awnset.add(word[:-1])
    return awnset",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( comment ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ) ( comment ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( comment ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( subscript ( identifier ) ( slice ( unary_operator ( integer ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ),92,"{""filename"":""Charles Deberlanger/geometrische-letters.py"",""fullName"":""Charles Deberlanger"",""id"":""13281"",""status"":""correct"",""submissionID"":""6750648"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:14:30.000Z"",""labels"":""stat""}"
184,../exam-folder/Shuaiqi Wang/geometrische-letters.py,"
def read_font(filname):
    """"""
    >>> font = read_font('font.txt')
    >>> font['E']
    (4, 0)
    >>> font['R']
    (2, 1)
    >>> font['G']
    (1, 1)
    >>> font['O']
    (0, 1)
    """"""
    text = ''
    with open(filname,'r',encoding='utf-8') as fp:
        text = fp.read()
    words = text.split('\n')
    res = {}
    for word in words:
        word_list = word.split(' ')
        res[word_list[0]] = (int(word_list[1]),int(word_list[2]))
    return res
def line_count(word, description):
    """"""
    >>> line_count('ERGONOMICS', font)
    (17, 6)
    >>> line_count('ERGONOMIC"",s', font)
    (17, 6)
    """"""
    word = list(word)
    lines = [0,0]
    for ch in word:
        if ch.isalpha():
            line = description[ch.upper()]
            lines[0] += line[0]
            lines[1] += line[1]
    return tuple(lines)

def count_straight_lines(word, description):
    """"""
    >>> count_straight_lines('ERGONOMICS', font)
    17
    """"""
    return  line_count(word,description)[0]

def count_curved_lines(word, description):
    """"""
    >>> count_curved_lines('ERGONOMICS', font)
    6
    """"""
    return line_count(word,description)[1]

def straight_lines_only(filename, description):
    """"""
    >>> straight_lines_only('dictionary.txt', font)
    {'ALKALINE', 'MILLENNIAL', 'INFINITELY'}
    """"""
    text = None
    with open(filename,'r',encoding='utf-8') as fp:
        text = fp.read()
    words = text.split('\n')
    res = set()
    for word in words:
        if(count_straight_lines(word,description)!=0) and count_curved_lines(word,description)==0:
            res.add(word)
    return res
def curved_lines_only(filename,description):
    """"""
    >>> curved_lines_only('dictionary.txt', font)
    {'COCCUS', 'COUSCOUS'}
    """"""
    text = None
    with open(filename, 'r', encoding='utf-8') as fp:
        text = fp.read()
    words = text.split('\n')
    res = set()
    for word in words:
        if (count_straight_lines(word, description) == 0) and count_curved_lines(word, description) != 0:
            res.add(word)
    return res
def balanced_lines(filename,description):
    """"""
    >>> res = {'AUGUSTUS', 'CROSSROAD', 'SUDOKU', 'COLUMBUS', 'PROCESSORS'}
    >>> balanced_lines('dictionary.txt', font) == res
    True
    """"""
    text = None
    with open(filename, 'r', encoding='utf-8') as fp:
        text = fp.read()
    words = text.split('\n')
    res = set()
    for word in words:
        if count_straight_lines(word, description) == count_curved_lines(word, description):
            res.add(word)
    return res

if __name__ == '__main__':
    import doctest

    font = read_font('font.txt')
    doctest.testmod()",( module ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( string ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ( keyword_argument ( identifier ) ( string ) ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( list ( integer ) ( integer ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ( block ( expression_statement ( assignment ( identifier ) ( subscript ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ( expression_statement ( augmented_assignment ( subscript ( identifier ) ( integer ) ) ( subscript ( identifier ) ( integer ) ) ) ) ( expression_statement ( augmented_assignment ( subscript ( identifier ) ( integer ) ) ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( call ( identifier ) ( argument_list ( identifier ) ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( return_statement ( subscript ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( none ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ( keyword_argument ( identifier ) ( string ) ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( boolean_operator ( parenthesized_expression ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( none ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ( keyword_argument ( identifier ) ( string ) ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( boolean_operator ( parenthesized_expression ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( integer ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( string ) ) ( expression_statement ( assignment ( identifier ) ( none ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ( keyword_argument ( identifier ) ( string ) ) ) ) ( identifier ) ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ) ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( identifier ) ( identifier ) ) ) ) ( block ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( identifier ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( if_statement ( comparison_operator ( identifier ) ( string ) ) ( block ( import_statement ( dotted_name ( identifier ) ) ) ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( string ) ) ) ) ) ( expression_statement ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ) ),134,"{""filename"":""Shuaiqi Wang/geometrische-letters.py"",""fullName"":""Shuaiqi Wang"",""id"":""13598"",""status"":""runtime error"",""submissionID"":""6750470"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:09:25.000Z"",""labels"":""keuz""}"
185,../exam-folder/Nurefsan Davulcu/geometrische-letters.py,"# function that returns dictionary describing contents of a jetbrains mono font text file
def read_font(file):

    d = {}
    with open(file, 'r') as font:
        for line in font:
            lst = line.split()
            d[lst[0]] = (int(lst[1]),int(lst[2]))
    return d

# function that returns number (int) of straight lines used in writing the word w in font given dictionary
def count_straight_lines(w, d):
    
    total = 0
    for char in w:
        if char in d:
            total += d[char][0]
    return total
    
    # alternate solution - comprehesion but have to store 
    #total = [d[char][0] for char in w if char in d]
    #sum(total)
    
# function that returns number (int) of curved lines used in writing the word w in font given dictionary
def count_curved_lines(w, d):

    total = 0
    for char in w:
        if char in d:
            total += d[char][1]
    return total
    
    # alternate solution - comprehesion but have to store 
    #total = [d[char][1] for char in w if char in d]
    #sum(total)
    
# function that returns set of words containing straight lines only
def straight_lines_only(w_file, d):

    file = open(w_file, 'r')
    # if no curved lines then add to set and return
    return {w.strip('\n') for w in file if count_curved_lines(w.strip('\n'), d) == 0}

# function that returns set of words containing curved lines only
def curved_lines_only(w_file, d):
    
    file = open(w_file, 'r')
    # if no straight lines then add to set and return
    return {w.strip('\n') for w in file if count_straight_lines(w.strip('\n'), d) == 0}

# The function must return a set containing all words (str) in the given list that are written with
# and equal number of straight and curved lines in font .
def balanced_lines(w_file, d):

    file = open(w_file, 'r')
    # if number of curved lines == number of straight lines then add to set and return
    return {w.strip('\n') for w in file if count_straight_lines(w.strip('\n'), d) == count_curved_lines(w.strip('\n'), d)}",( module ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( dictionary ) ) ) ( with_statement ( with_clause ( with_item ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ( identifier ) ) ) ( block ( for_statement ( identifier ) ( identifier ) ( block ( expression_statement ( assignment ( identifier ) ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ) ) ) ) ( expression_statement ( assignment ( subscript ( identifier ) ( subscript ( identifier ) ( integer ) ) ) ( tuple ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ( call ( identifier ) ( argument_list ( subscript ( identifier ) ( integer ) ) ) ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ) ) ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ( comment ) ( comment ) ( comment ) ) ) ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( integer ) ) ) ( for_statement ( identifier ) ( identifier ) ( block ( if_statement ( comparison_operator ( identifier ) ( identifier ) ) ( block ( expression_statement ( augmented_assignment ( identifier ) ( subscript ( subscript ( identifier ) ( identifier ) ) ( integer ) ) ) ) ) ) ) ) ( return_statement ( identifier ) ) ( comment ) ( comment ) ( comment ) ) ) ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( comment ) ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( comparison_operator ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ) ( integer ) ) ) ) ) ) ) ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( comment ) ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( comparison_operator ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ) ( integer ) ) ) ) ) ) ) ( comment ) ( comment ) ( function_definition ( identifier ) ( parameters ( identifier ) ( identifier ) ) ( block ( expression_statement ( assignment ( identifier ) ( call ( identifier ) ( argument_list ( identifier ) ( string ) ) ) ) ) ( comment ) ( return_statement ( set_comprehension ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( for_in_clause ( identifier ) ( identifier ) ) ( if_clause ( comparison_operator ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ) ( call ( identifier ) ( argument_list ( call ( attribute ( identifier ) ( identifier ) ) ( argument_list ( string ( escape_sequence ) ) ) ) ( identifier ) ) ) ) ) ) ) ) ) ),87,"{""filename"":""Nurefsan Davulcu/geometrische-letters.py"",""fullName"":""Nurefsan Davulcu"",""id"":""13714"",""status"":""correct"",""submissionID"":""6750179"",""nameEN"":""Geometric letters"",""nameNL"":""Geometrische letters"",""exerciseID"":""1522917022"",""createdAt"":""2020-12-14T15:00:48.000Z"",""labels"":""""}"
