import { NumericRangesTuple } from "./benchmarkManager";
import { Range } from "./range";
import { RangesTuple } from "./summary";

export enum LineState {
  Hit, // A line is both expected and confirmed
  Miss, // A line is expected but not confirmed
  FalseHit, // A line is confirmed but not expected
}

/**
 * Note: the results might be confusing at times because for example the total amount of missed lines might be bigger
 * then the range you gave. This is because it counts the missed lines in *both* files. This is so because the ranges
 * are not guaranteed to be of equal length.
 */
export interface BenchmarkResults {
  matchedLines: number; // A line appears in both the expected and actual ranges
  missedLines: number; // When a line is expected but not seen in the actual ranges.
  falseLines: number; // When a line appears in the actual ranges but is not expected.
  falseMatches: number; // When a rangesTuple generated by the matcher is deemed invalid.
  falseMatchingLines: number; // The total amount of lines in such a rangesTuple
  matchingRangesTuples: RangesTuple[]; // The rangesTuples in the actual list that had a match.
  falseRangesTuples: RangesTuple[]; // The rangesTuples in the actual list that had no matches.
}
/**
 * Get the lineState with the hightest precedence. Will throw an error when a Miss and FalseHit are compared.
 * @param lineState1 The first line state.
 * @param lineState2 The second line state.
 */
function getHigherPrecedence(lineState1: LineState | undefined, lineState2: LineState): LineState {
  if (lineState1 === undefined) {
    return lineState2;
  } else if (lineState1 === lineState2) {
    return lineState1;
  } else if (lineState1 === LineState.Hit || lineState2 === LineState.Hit) {
    return LineState.Hit;
  } else {
    throw Error("Cannot compare a FalseHit and a miss");
  }
}

/**
 * A class used to generate the results for a benchmark.
 */
export class BenchmarkMatcher {
  public static toRangesTuple([[from1, to1], [from2, to2]]: NumericRangesTuple): RangesTuple {
    return [new Range(from1 - 1, to1 - 1), new Range(from2 - 1, to2 - 1)];
  }
  private readonly expected: RangesTuple[];
  private readonly dataStructure: RangesTuple[][];

  private readonly map: Array<
    Array<boolean | ((rt1: RangesTuple, rt2: RangesTuple) => boolean)>
  > = [
    [true, false, this.isAcceptableRatio, this.isAcceptableRatio],
    [false, true, this.isAcceptableRatio, this.isAcceptableRatio],
    [this.isAcceptableRatio, this.isAcceptableRatio, true, false],
    [this.isAcceptableRatio, this.isAcceptableRatio, false, true],
  ];

  private readonly file1LinesStates: LineState[] = new Array();
  private readonly file2LinesStates: LineState[] = new Array();
  /**
   * @param expected The expected numeric rangesTuple
   */
  constructor(expected: RangesTuple[]) {
    this.expected = expected;
    this.dataStructure = new Array();

    // Registers all the rangesTuple based on the line from the first range in the rangesTuple. This is done so that we
    // don't have to do a double for loop over all the ranges but only the relevant ones.
    for (const rangesTuple of this.expected.values()) {
      for (let index = rangesTuple[0].from; index <= rangesTuple[0].to; index += 1) {
        let subArray: RangesTuple[] = this.dataStructure[index];
        if (subArray === undefined) {
          subArray = new Array();
          this.dataStructure[index] = subArray;
        }
        subArray.push(rangesTuple);
      }
    }
  }

  /**
   * Calculates the statistics returned by the benchmark. See [[BenchmarkResults]] for more information.
   * @param actual The actual matches return from the match.
   */
  public toBePresentIn(actual: RangesTuple[]): BenchmarkResults {
    const benchmarkResults: BenchmarkResults = {
      falseLines: 0,
      falseMatches: 0,
      falseMatchingLines: 0,
      falseRangesTuples: [],
      matchedLines: 0,
      matchingRangesTuples: [],
      missedLines: 0,
    };

    for (const actualRT of actual.values()) {
      let hasAMatch: boolean = false;
      for (const expectedRT of this.getMatchingRangesTuples(actualRT[0])) {
        if (this.isAcceptedCombination(actualRT, expectedRT)) {
          benchmarkResults.matchingRangesTuples.push(actualRT);
          hasAMatch = true;
          this.applyLineStates(expectedRT[0], actualRT[0], true);
          this.applyLineStates(expectedRT[1], actualRT[1], false);
        }
      }
      if (!hasAMatch) {
        benchmarkResults.falseRangesTuples.push(actualRT);
        benchmarkResults.falseMatches += 1;
        benchmarkResults.falseMatchingLines +=
          actualRT[0].getLineCount() + actualRT[1].getLineCount();
      }
    }

    // TODO merge these two together.
    for (const [, lineState] of this.file1LinesStates.entries()) {
      switch (lineState) {
        case LineState.Hit:
          benchmarkResults.matchedLines += 1;
          break;
        case LineState.Miss:
          benchmarkResults.missedLines += 1;
          break;
        case LineState.FalseHit:
          benchmarkResults.falseLines += 1;
          break;
      }
    }
    for (const [, lineState] of this.file2LinesStates.entries()) {
      switch (lineState) {
        case LineState.Hit:
          benchmarkResults.matchedLines += 1;
          break;
        case LineState.Miss:
          benchmarkResults.missedLines += 1;
          break;
        case LineState.FalseHit:
          benchmarkResults.falseLines += 1;
          break;
      }
    }

    return benchmarkResults;
  }

  /**
   * Calculates if the ratio of the amount of lines within the expected range and the amount outside is small enough.
   * @param rt1 The first rangesTuple.
   * @param tr2 The second rangesTuple.
   */
  // @ts-ignore; TODO
  private isAcceptableRatio(rt1: RangesTuple, tr2: RangesTuple): boolean {
    return true;
  }

  /**
   * Decides if it is useful for the two rangesTuple to be compared.
   * @param actualRT The rangesTuple returned by the matcher.
   * @param expectedRT The rangesTuple expected from the result.
   */
  private isAcceptedCombination(actualRT: RangesTuple, expectedRT: RangesTuple): boolean {
    if (
      actualRT[0].overlappingLinesAmount(expectedRT[0]) <= 0 ||
      actualRT[1].overlappingLinesAmount(expectedRT[1]) <= 0
    ) {
      return false;
    }
    const type1: RangesTupleType = this.getType(actualRT);
    const type2: RangesTupleType = this.getType(expectedRT);

    const returnValue: boolean | ((rt1: RangesTuple, rt2: RangesTuple) => boolean) = this.map[
      type1
    ][type2];

    if (typeof returnValue === "boolean") {
      return returnValue;
    } else {
      return returnValue(actualRT, expectedRT);
    }
  }

  /**
   * Calculates the type for the given rangesTuple. See [[RangesTupleType]] for more information about what the types
   * mean.
   * @param param0 The rangesTuple you want the type of.
   */
  private getType([r1, r2]: RangesTuple): RangesTupleType {
    if (r1.to < r2.to && r1.from > r2.from) {
      return RangesTupleType.ExpectedSmallerThenActual;
    } else if (r2.to < r1.to && r2.from > r1.from) {
      return RangesTupleType.ExpectedBiggerThenActual;
    } else if (r1.to <= r2.to && r1.from <= r2.from) {
      return RangesTupleType.ActualShiftUpFromExpected;
    } else {
      return RangesTupleType.ActualShiftUpFromExpected;
    }
  }

  /**
   * Calculate all the linestates and add them to the corresping file.
   * @param expected The expected range.
   * @param actual The actual range.
   * @param firstFile A boolean representing wether this is for the matched file or the matchingfile.
   */
  private applyLineStates(expected: Range, actual: Range, firstFile: boolean) {
    const fileStates: LineState[] = firstFile ? this.file1LinesStates : this.file2LinesStates;
    for (
      let lineNumber = Math.min(expected.from, actual.from);
      lineNumber <= Math.max(expected.to, actual.to);
      lineNumber += 1
    ) {
      let lineState: LineState;
      const inExpected = expected.includes(lineNumber);
      const inActual = actual.includes(lineNumber);
      if (inExpected && inActual) {
        lineState = LineState.Hit;
      } else if (inExpected && !inActual) {
        lineState = LineState.Miss;
      } else if (!inExpected && inActual) {
        lineState = LineState.FalseHit;
      } else {
        continue;
      }

      fileStates[lineNumber] = getHigherPrecedence(fileStates[lineNumber], lineState);
    }
  }

  /**
   *
   * @param range A range from the actual rangesTuple you want all the relevant expected ranges of.
   */
  private getMatchingRangesTuples(range: Range): Set<RangesTuple> {
    const returnSet: Set<RangesTuple> = new Set();
    for (let index = range.from; index <= range.to; index += 1) {
      const rangesTupleArray = this.dataStructure[index] || [];
      rangesTupleArray.forEach(rangesTuple => returnSet.add(rangesTuple));
    }
    return returnSet;
  }
}

/**
 * The Types of rangesTuples configurations when they overlap.
 */
enum RangesTupleType {
  // Both the edge values from the expected range lie within the actual range.
  ExpectedSmallerThenActual = 0,
  // Both the edge values from the actual range lie within the expected range.
  ExpectedBiggerThenActual = 1,
  // The upper bound of the actual range lies outside of the expected range while the lower bound lies within.
  ActualShiftUpFromExpected = 2,
  // The lower bound of the actual range lies outside of the expected range while the lower bound lies outside.
  ActualShiftDownFromExpected = 3,
}
