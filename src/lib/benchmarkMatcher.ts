import { NumericRangesTuple } from "./benchmarkManager";
import { Range } from "./range";
import { RangesTuple } from "./summary";

export enum LineState {
  Hit, // A line is both expected and confirmed
  Miss, // A line is expected but not confirmed
  FalseHit, // A line is confirmed but not expected
}

/**
 * Get the lineState with the hightest precedence. Will throw an error when a Miss and FalseHit are compared.
 * @param lineState1 The first line state.
 * @param lineState2 The second line state.
 */
function getHigherPrecedence(lineState1: LineState | undefined, lineState2: LineState): LineState {
  if (lineState1 === undefined) {
    return lineState2;
  } else if (lineState1 === lineState2) {
    return lineState1;
  } else if (lineState1 === LineState.Hit || lineState2 === LineState.Hit) {
    return LineState.Hit;
  } else {
    throw Error("Cannot compare a FalseHit and a miss");
  }
}

/**
 * A class used to generate the results for a benchmark.
 */
export class BenchmarkMatcher {
  public static toRangesTuple([[from1, to1], [from2, to2]]: NumericRangesTuple): RangesTuple {
    return [new Range(from1 - 1, to1 - 1), new Range(from2 - 1, to2 - 1)];
  }
  private readonly expected: RangesTuple[];
  private readonly dataStructure: RangesTuple[][];

  private readonly map: Array<
    Array<boolean | ((rt1: RangesTuple, rt2: RangesTuple) => boolean)>
  > = [
    [true, false, this.isAcceptableRatio, this.isAcceptableRatio],
    [false, true, this.isAcceptableRatio, this.isAcceptableRatio],
    [this.isAcceptableRatio, this.isAcceptableRatio, true, false],
    [this.isAcceptableRatio, this.isAcceptableRatio, false, true],
  ];

  private readonly file1LinesStates: LineState[] = new Array();
  private readonly file2LinesStates: LineState[] = new Array();
  /**
   * @param expected The expected numeric rangesTuple
   */
  constructor(expected: NumericRangesTuple[]) {
    const mapped: RangesTuple[] = expected.map(expectedValue =>
      BenchmarkMatcher.toRangesTuple(expectedValue),
    );
    this.expected = mapped;
    this.dataStructure = new Array();

    // Registers all the rangesTuple based on the line from the first range in the rangesTuple. This is done so that we
    // don't have to do a double for loop over all the ranges but only the relevant ones.
    for (const [range1, range2] of this.expected.values()) {
      for (let index = range1.from; index <= range1.to; index += 1) {
        let subArray: RangesTuple[] = this.dataStructure[index];
        if (subArray === undefined) {
          subArray = new Array();
          this.dataStructure[index] = subArray;
        }
        subArray.push([range1, range2]);
      }
    }
  }

  /**
   * Calculates the statistics returned by the benchmark.
   * @param actual The actual matches return from the match.
   */
  public toBePresentIn(actual: RangesTuple[]) {
    let matchedLines: number = 0; // A line appears in both the expected and actual ranges
    let missedLines: number = 0; // When a line is expected but not seen in the actual ranges.
    let falseLines: number = 0; // When a line appears in the actual ranges but is not expected.
    let falseMatches: number = 0; // When a rangesTuple generated by the matcher is deemed invalid.
    let falseMatchingLines: number = 0; // The total amount of lines in such a rangesTuple

    for (const actualRT of actual.values()) {
      let hasAMatch: boolean = false;
      for (const expectedRT of this.getMatchingRangesTuples(actualRT[0])) {
        if (this.isAcceptedCombination(actualRT, expectedRT)) {
          hasAMatch = true;
          this.applyLineStates(actualRT[0], expectedRT[0], true);
          this.applyLineStates(actualRT[1], expectedRT[1], true);
        }
      }
      if (!hasAMatch) {
        falseMatches += 1;
        falseMatchingLines += actualRT[0].getLineCount() + actualRT[1].getLineCount();
      }
    }

    for (const [, lineState] of this.file1LinesStates.entries()) {
      switch (lineState) {
        case LineState.Hit:
          matchedLines += 1;
          break;
        case LineState.Miss:
          missedLines += 1;
          break;
        case LineState.FalseHit:
          falseLines += 1;
          break;
      }
    }
    for (const [, lineState] of this.file2LinesStates.entries()) {
      switch (lineState) {
        case LineState.Hit:
          matchedLines += 1;
          break;
        case LineState.Miss:
          missedLines += 1;
          break;
        case LineState.FalseHit:
          falseLines += 1;
          break;
      }
    }

    console.info(
      `\tmatchedLines: ${matchedLines}, missedLines: ${missedLines}, falseLines: ${falseLines}, ` +
        `falseMatches: ${falseMatches}, falseMatchingLines: ${falseMatchingLines}`,
    );
  }

  /**
   * Calculates if the ratio of the amount of lines within the expected range and the amount outside is small enough.
   * @param rt1 The first rangesTuple.
   * @param tr2 The second rangesTuple.
   */
  // @ts-ignore; TODO
  private isAcceptableRatio(rt1: RangesTuple, tr2: RangesTuple): boolean {
    return true;
  }

  /**
   * Decides if it is useful for the two rangesTuple to be compared.
   * @param actualRT The rangesTuple returned by the matcher.
   * @param expectedRT The rangesTuple expected from the result.
   */
  private isAcceptedCombination(actualRT: RangesTuple, expectedRT: RangesTuple): boolean {
    if (
      actualRT[0].overlappingLinesAmount(expectedRT[0]) <= 0 ||
      actualRT[1].overlappingLinesAmount(expectedRT[1]) <= 0
    ) {
      return false;
    }
    const type1: RangesTupleType = this.getType(actualRT);
    const type2: RangesTupleType = this.getType(expectedRT);

    const returnValue: boolean | ((rt1: RangesTuple, rt2: RangesTuple) => boolean) = this.map[
      type1
    ][type2];

    if (typeof returnValue === "boolean") {
      return returnValue;
    } else {
      return returnValue(actualRT, expectedRT);
    }
  }

  /**
   * Calculates the type for the given rangesTuple. See [[RangesTupleType]] for more information about what the types
   * mean.
   * @param param0 The rangesTuple you want the type of.
   */
  private getType([r1, r2]: RangesTuple): RangesTupleType {
    if (r1.to < r2.to && r1.from > r2.from) {
      return RangesTupleType.ExpectedSmallerThenActual;
    } else if (r2.to < r1.to && r2.from > r1.from) {
      return RangesTupleType.ExpectedBiggerThenActual;
    } else if (r1.to <= r2.to && r1.from <= r2.from) {
      return RangesTupleType.ActualShiftUpFromExpected;
    } else {
      return RangesTupleType.ActualShiftUpFromExpected;
    }
  }

  /**
   * Calculate all the linestates and add them to the corresping file.
   * @param expected The expected range.
   * @param actual The actual range.
   * @param firstFile A boolean representing wether this is for the matched file or the matchingfile.
   */
  private applyLineStates(expected: Range, actual: Range, firstFile: boolean) {
    const fileStates: LineState[] = firstFile ? this.file1LinesStates : this.file2LinesStates;
    for (
      let lineNumber = Math.min(expected.from, actual.from);
      lineNumber <= Math.max(expected.to, actual.to);
      lineNumber += 1
    ) {
      let lineState: LineState;
      const inRange1 = expected.includes(lineNumber);
      const inRange2 = actual.includes(lineNumber);
      if (inRange1 && inRange2) {
        lineState = LineState.Hit;
      } else if (inRange1 && !inRange2) {
        lineState = LineState.Miss;
      } else if (!inRange1 && inRange2) {
        lineState = LineState.FalseHit;
      } else {
        continue;
      }

      fileStates[lineNumber] = getHigherPrecedence(fileStates[lineNumber], lineState);
    }
  }

  /**
   *
   * @param range A range from the actual rangesTuple you want all the relevant expected ranges of.
   */
  private getMatchingRangesTuples(range: Range): Set<RangesTuple> {
    const returnSet: Set<RangesTuple> = new Set();
    for (let index = range.from; index <= range.to; index += 1) {
      const rangesTupleArray = this.dataStructure[index] || [];
      rangesTupleArray.forEach(rangesTuple => returnSet.add(rangesTuple));
    }
    return returnSet;
  }
}

/**
 * The Types of rangesTuples configurations when they overlap.
 */
enum RangesTupleType {
  // Both the edge values from the expected range lie within the actual range.
  ExpectedSmallerThenActual = 0,
  // Both the edge values from the actual range lie within the expected range.
  ExpectedBiggerThenActual = 1,
  // The upper bound of the actual range lies outside of the expected range while the lower bound lies within.
  ActualShiftUpFromExpected = 2,
  // The lower bound of the actual range lies outside of the expected range while the lower bound lies outside.
  ActualShiftDownFromExpected = 3,
}
