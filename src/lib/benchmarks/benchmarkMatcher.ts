import { Range } from "../range";
import { RangesTuple } from "../utils";
import { BenchmarkHelper } from "./benchmarkHelper";
import { NumericRangesTuple } from "./benchmarkManager";

export enum LineState {
  Hit, // A line is both expected and confirmed
  Miss, // A line is expected but not confirmed
  FalseHit, // A line is confirmed but not expected
}

/**
 * A class that holds the results of a benchmark.
 * Note: the results might be confusing at times because for example the total amount of missed lines might be bigger
 * then the range you gave. This is because it counts the missed lines in *both* files. This is so because the ranges
 * are not guaranteed to be of equal length.
 */
export interface BenchmarkResults {
  matchedLines: number; // A line appears in both the expected and actual ranges
  missedLines: number; // When a line is expected but not seen in the actual ranges.
  falseLines: number; // When a line appears in the actual ranges but is not expected.
  falseMatches: number; // When a rangesTuple generated by the matcher is deemed invalid.
  falseMatchingLines: number; // The total amount of lines in such a rangesTuple

  matchingRangesTuples: RangesTuple[]; // The rangesTuples in the actual list that had a match.
  falseRangesTuples: RangesTuple[]; // The rangesTuples in the actual list that had no matches.
  expected: RangesTuple[]; // The expected ranges.
  matchingFile: string; // The matched file.
  matchedFile: string; // The matching file.
}
/**
 * Get the lineState with the hightest precedence. Will throw an error when a Miss and FalseHit are compared.
 * @param lineState1 The first line state.
 * @param lineState2 The second line state.
 */
function getHigherPrecedence(lineState1: LineState | undefined, lineState2: LineState): LineState {
  if (lineState1 === undefined) {
    return lineState2;
  } else if (lineState1 === lineState2) {
    return lineState1;
  } else if (lineState1 === LineState.Hit || lineState2 === LineState.Hit) {
    return LineState.Hit;
  } else {
    throw Error("Cannot compare a FalseHit and a miss");
  }
}

/**
 * A class used to generate the results for a benchmark.
 */
export class BenchmarkMatcher {
  public get result(): BenchmarkResults | undefined {
    return this.benchmarkResults;
  }
  public static toRangesTuple([[from1, to1], [from2, to2]]: NumericRangesTuple): RangesTuple {
    return [new Range(from1 - 1, to1 - 1), new Range(from2 - 1, to2 - 1)];
  }

  /**
   * Calculates if the ratio of the amount of lines within the expected range and the amount outside is small enough.
   * @param rt1 The first rangesTuple.
   * @param tr2 The second rangesTuple.
   */
  public acceptableRatio: number = 0.5;
  private readonly dataStructure: RangesTuple[][];

  private readonly map: Array<
    Array<boolean | ((rt1: RangesTuple, rt2: RangesTuple) => boolean)>
  > = [
    [true, false, (_, rt) => this.isAcceptableRatio(rt), (_, rt) => this.isAcceptableRatio(rt)],
    [false, true, (_, rt) => this.isAcceptableRatio(rt), (_, rt) => this.isAcceptableRatio(rt)],
    [rt => this.isAcceptableRatio(rt), rt => this.isAcceptableRatio(rt), true, false],
    [rt => this.isAcceptableRatio(rt), rt => this.isAcceptableRatio(rt), false, true],
  ];

  // TODO better naming
  private readonly file1LinesStates: LineState[] = new Array();
  private readonly file2LinesStates: LineState[] = new Array();

  private readonly helper: BenchmarkHelper;

  private expected: RangesTuple[] | undefined;
  private matchingFile: string | undefined;
  private matchedFile: string | undefined;

  private actual: RangesTuple[] | undefined;

  /**
   * Calculates the statistics returned by the benchmark. See [[BenchmarkResults]] for more information.
   * @param actual The actual matches return from the match.
   */

  private benchmarkResults: BenchmarkResults | undefined;
  /**
   * @param expected The expected numeric rangesTuple
   */
  constructor(helper: BenchmarkHelper) {
    this.helper = helper;
    this.dataStructure = new Array();
  }

  public async match(matchedFile: string, matchingFile: string): Promise<this> {
    this.matchingFile = matchingFile;
    this.matchedFile = matchedFile;
    this.actual = await this.helper.match(matchedFile, matchingFile);
    return this;
  }

  public toBePresentInMatch(): void {
    if (this.actual === undefined) {
      throw Error("cannot call toBePresentInMatch without calling match");
    }

    if (this.expected === undefined) {
      throw Error("cannot call toBePresentInMatch without calling expect");
    }

    this.benchmarkResults = {
      expected: this.expected,
      falseLines: 0,
      falseMatches: 0,
      falseMatchingLines: 0,
      falseRangesTuples: [],
      matchedFile: this.matchedFile as string,
      matchedLines: 0,
      matchingFile: this.matchingFile as string,
      matchingRangesTuples: [],
      missedLines: 0,
    };

    for (const actualRT of this.actual.values()) {
      let hasAMatch: boolean = false;
      for (const expectedRT of this.getMatchingRangesTuples(actualRT[0])) {
        if (this.isAcceptedCombination(actualRT, expectedRT)) {
          this.benchmarkResults.matchingRangesTuples.push(actualRT);
          hasAMatch = true;
          this.applyLineStates(expectedRT[0], actualRT[0], true);
          this.applyLineStates(expectedRT[1], actualRT[1], false);
        }
      }
      if (!hasAMatch) {
        this.benchmarkResults.falseRangesTuples.push(actualRT);
        this.benchmarkResults.falseMatches += 1;
        this.benchmarkResults.falseMatchingLines +=
          actualRT[0].getLineCount() + actualRT[1].getLineCount();
      }
    }

    for (const [, lineState] of this.file1LinesStates.concat(this.file2LinesStates).entries()) {
      switch (lineState) {
        case LineState.Hit:
          this.benchmarkResults.matchedLines += 1;
          break;
        case LineState.Miss:
          this.benchmarkResults.missedLines += 1;
          break;
        case LineState.FalseHit:
          this.benchmarkResults.falseLines += 1;
          break;
      }
    }
  }

  public expect(expected: NumericRangesTuple[]): this {
    this.expected = expected.map(BenchmarkMatcher.toRangesTuple);

    // Registers all the rangesTuple based on the line from the first range in the rangesTuple. This is done so that we
    // don't have to do a double for loop over all the ranges but only the relevant ones.
    for (const rangesTuple of this.expected.values()) {
      for (let index = rangesTuple[0].from; index <= rangesTuple[0].to; index += 1) {
        let subArray: RangesTuple[] = this.dataStructure[index];
        if (subArray === undefined) {
          subArray = new Array();
          this.dataStructure[index] = subArray;
        }
        subArray.push(rangesTuple);
      }
    }
    return this;
  }
  private isAcceptableRatio([expected, actual]: RangesTuple): boolean {
    if (expected.from <= actual.from && actual.from <= expected.to) {
      return (expected.to - actual.from) / (expected.to - actual.to) >= this.acceptableRatio;
    } else {
      return (actual.to - expected.from) / (expected.from - actual.from) >= this.acceptableRatio;
    }
  }

  /**
   * Decides if it is useful for the two rangesTuple to be compared.
   * @param actualRT The rangesTuple returned by the matcher.
   * @param expectedRT The rangesTuple expected from the result.
   */
  private isAcceptedCombination(
    [file1Actual, file2Actual]: RangesTuple,
    [file1Expected, file2Expected]: RangesTuple,
  ): boolean {
    if (
      file1Actual.overlappingLinesAmount(file1Expected) <= 0 ||
      file2Actual.overlappingLinesAmount(file2Expected) <= 0
    ) {
      return false;
    }
    const file1RangesTuple: RangesTuple = [file1Expected, file1Actual];
    const file2RangesTuple: RangesTuple = [file2Expected, file2Actual];

    const type1: RangesTupleType = this.getType(file1RangesTuple);
    const type2: RangesTupleType = this.getType(file2RangesTuple);

    const returnValue: boolean | ((rt1: RangesTuple, rt2: RangesTuple) => boolean) = this.map[
      type1
    ][type2];

    if (typeof returnValue === "boolean") {
      return returnValue;
    } else {
      return returnValue(file1RangesTuple, file2RangesTuple);
    }
  }

  // TODO can be made sattic
  /**
   * Calculates the type for the given rangesTuple. See [[RangesTupleType]] for more information about what the types
   * mean.
   * @param param0 The rangesTuple you want the type of.
   */
  private getType([r1, r2]: RangesTuple): RangesTupleType {
    if (r1.to < r2.to && r1.from > r2.from) {
      return RangesTupleType.ExpectedSmallerThenActual;
    } else if (r2.to < r1.to && r2.from > r1.from) {
      return RangesTupleType.ExpectedBiggerThenActual;
    } else if (r1.to <= r2.to && r1.from <= r2.from) {
      return RangesTupleType.ActualShiftUpFromExpected;
    } else {
      return RangesTupleType.ActualShiftUpFromExpected;
    }
  }

  /**
   * Calculate all the linestates and add them to the corresping file.
   * @param expected The expected range.
   * @param actual The actual range.
   * @param firstFile A boolean representing wether this is for the matched file or the matchingfile.
   */
  private applyLineStates(expected: Range, actual: Range, firstFile: boolean) {
    const fileStates: LineState[] = firstFile ? this.file1LinesStates : this.file2LinesStates;
    for (
      let lineNumber = Math.min(expected.from, actual.from);
      lineNumber <= Math.max(expected.to, actual.to);
      lineNumber += 1
    ) {
      let lineState: LineState;
      const inExpected = expected.includes(lineNumber);
      const inActual = actual.includes(lineNumber);
      if (inExpected && inActual) {
        lineState = LineState.Hit;
      } else if (inExpected && !inActual) {
        lineState = LineState.Miss;
      } else if (!inExpected && inActual) {
        lineState = LineState.FalseHit;
      } else {
        continue;
      }

      fileStates[lineNumber] = getHigherPrecedence(fileStates[lineNumber], lineState);
    }
  }

  /**
   *
   * @param range A range from the actual rangesTuple you want all the relevant expected ranges of.
   */
  private getMatchingRangesTuples(range: Range): Set<RangesTuple> {
    const returnSet: Set<RangesTuple> = new Set();
    for (let index = range.from; index <= range.to; index += 1) {
      const rangesTupleArray = this.dataStructure[index] || [];
      rangesTupleArray.forEach(rangesTuple => returnSet.add(rangesTuple));
    }
    return returnSet;
  }
}

/**
 * The Types of rangesTuples configurations when they overlap.
 */
enum RangesTupleType {
  // Both the edge values from the expected range lie within the actual range.
  ExpectedSmallerThenActual = 0,
  // Both the edge values from the actual range lie within the expected range.
  ExpectedBiggerThenActual = 1,
  // The upper bound of the actual range lies outside of the expected range while the lower bound lies within.
  ActualShiftUpFromExpected = 2,
  // The lower bound of the actual range lies outside of the expected range while the lower bound lies outside.
  ActualShiftDownFromExpected = 3,
}
